{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array\n};\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels'\n};\n\nclass MapBox extends Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height\n    }).fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom\n      }\n    };\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds\n    } = this.props;\n    const { viewport } = this.state;\n    const isDragging =\n    viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = width * 0.5 / 100;\n    const offsetVertical = height * 0.5 / 100;\n    const bbox = [\n    bounds[0][0] - offsetHorizontal,\n    bounds[0][1] - offsetVertical,\n    bounds[1][0] + offsetHorizontal,\n    bounds[1][1] + offsetVertical];\n\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      _jsx(MapGL, { ...\n        viewport,\n        mapStyle: mapStyle,\n        width: width,\n        height: height,\n        mapboxApiAccessToken: mapboxApiKey,\n        onViewportChange: this.handleViewportChange,\n        preserveDrawingBuffer: true, children:\n\n        _jsx(ScatterPlotGlowOverlay, { ...\n          viewport,\n          isDragging: isDragging,\n          locations: clusters,\n          dotRadius: pointRadius,\n          pointRadiusUnit: pointRadiusUnit,\n          rgb: rgb,\n          globalOpacity: globalOpacity,\n          compositeOperation: \"screen\",\n          renderWhileDragging: renderWhileDragging,\n          aggregation: hasCustomMetric ? aggregatorName : null,\n          lngLatAccessor: (location) => {\n            const { coordinates } = location.geometry;\n\n            return [coordinates[0], coordinates[1]];\n          } }\n        ) }\n      ));\n\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;const _default =\n\nMapBox;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(NOOP, \"NOOP\", \"/app/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(DEFAULT_MAX_ZOOM, \"DEFAULT_MAX_ZOOM\", \"/app/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(DEFAULT_POINT_RADIUS, \"DEFAULT_POINT_RADIUS\", \"/app/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(propTypes, \"propTypes\", \"/app/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(defaultProps, \"defaultProps\", \"/app/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(MapBox, \"MapBox\", \"/app/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["Component","PropTypes","MapGL","ViewportMercator","ScatterPlotGlowOverlay","jsx","_jsx","NOOP","DEFAULT_MAX_ZOOM","DEFAULT_POINT_RADIUS","propTypes","width","number","height","aggregatorName","string","clusterer","object","globalOpacity","hasCustomMetric","bool","mapStyle","mapboxApiKey","isRequired","onViewportChange","func","pointRadius","pointRadiusUnit","renderWhileDragging","rgb","array","bounds","defaultProps","MapBox","constructor","props","mercator","fitBounds","latitude","longitude","zoom","state","viewport","handleViewportChange","bind","setState","render","isDragging","undefined","offsetHorizontal","offsetVertical","bbox","clusters","getClusters","Math","round","mapboxApiAccessToken","preserveDrawingBuffer","children","locations","dotRadius","compositeOperation","aggregation","lngLatAccessor","location","coordinates","geometry","__reactstandin__regenerateByEval","key","code","eval","_default","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/app/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array,\n};\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels',\n};\n\nclass MapBox extends Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height,\n    }).fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom,\n      },\n    };\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds,\n    } = this.props;\n    const { viewport } = this.state;\n    const isDragging =\n      viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = (width * 0.5) / 100;\n    const offsetVertical = (height * 0.5) / 100;\n    const bbox = [\n      bounds[0][0] - offsetHorizontal,\n      bounds[0][1] - offsetVertical,\n      bounds[1][0] + offsetHorizontal,\n      bounds[1][1] + offsetVertical,\n    ];\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      <MapGL\n        {...viewport}\n        mapStyle={mapStyle}\n        width={width}\n        height={height}\n        mapboxApiAccessToken={mapboxApiKey}\n        onViewportChange={this.handleViewportChange}\n        preserveDrawingBuffer\n      >\n        <ScatterPlotGlowOverlay\n          {...viewport}\n          isDragging={isDragging}\n          locations={clusters}\n          dotRadius={pointRadius}\n          pointRadiusUnit={pointRadiusUnit}\n          rgb={rgb}\n          globalOpacity={globalOpacity}\n          compositeOperation=\"screen\"\n          renderWhileDragging={renderWhileDragging}\n          aggregation={hasCustomMetric ? aggregatorName : null}\n          lngLatAccessor={location => {\n            const { coordinates } = location.geometry;\n\n            return [coordinates[0], coordinates[1]];\n          }}\n        />\n      </MapGL>\n    );\n  }\n}\n\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;\n\nexport default MapBox;\n"],"mappings":"wSAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAAS,QAAQ,OAAO;AACjC,OAAOC,SAAS,MAAM,YAAY;AAClC,OAAOC,KAAK,MAAM,cAAc;AAChC,OAAOC,gBAAgB,MAAM,2BAA2B;AACxD,OAAOC,sBAAsB,MAAM,0BAA0B;AAC7D,OAAO,cAAc,CAAC,SAAAC,GAAA,IAAAC,IAAA;;AAEtB,MAAMC,IAAI,GAAGA,CAAA,KAAM,CAAC,CAAC;AACrB,OAAO,MAAMC,gBAAgB,GAAG,EAAE;AAClC,OAAO,MAAMC,oBAAoB,GAAG,EAAE;;AAEtC,MAAMC,SAAS,GAAG;EAChBC,KAAK,EAAEV,SAAS,CAACW,MAAM;EACvBC,MAAM,EAAEZ,SAAS,CAACW,MAAM;EACxBE,cAAc,EAAEb,SAAS,CAACc,MAAM;EAChCC,SAAS,EAAEf,SAAS,CAACgB,MAAM;EAC3BC,aAAa,EAAEjB,SAAS,CAACW,MAAM;EAC/BO,eAAe,EAAElB,SAAS,CAACmB,IAAI;EAC/BC,QAAQ,EAAEpB,SAAS,CAACc,MAAM;EAC1BO,YAAY,EAAErB,SAAS,CAACc,MAAM,CAACQ,UAAU;EACzCC,gBAAgB,EAAEvB,SAAS,CAACwB,IAAI;EAChCC,WAAW,EAAEzB,SAAS,CAACW,MAAM;EAC7Be,eAAe,EAAE1B,SAAS,CAACc,MAAM;EACjCa,mBAAmB,EAAE3B,SAAS,CAACmB,IAAI;EACnCS,GAAG,EAAE5B,SAAS,CAAC6B,KAAK;EACpBC,MAAM,EAAE9B,SAAS,CAAC6B;AACpB,CAAC;;AAED,MAAME,YAAY,GAAG;EACnBrB,KAAK,EAAE,GAAG;EACVE,MAAM,EAAE,GAAG;EACXK,aAAa,EAAE,CAAC;EAChBM,gBAAgB,EAAEjB,IAAI;EACtBmB,WAAW,EAAEjB,oBAAoB;EACjCkB,eAAe,EAAE;AACnB,CAAC;;AAED,MAAMM,MAAM,SAASjC,SAAS,CAAC;EAC7BkC,WAAWA,CAACC,KAAK,EAAE;IACjB,KAAK,CAACA,KAAK,CAAC;;IAEZ,MAAM,EAAExB,KAAK,EAAEE,MAAM,EAAEkB,MAAM,CAAC,CAAC,GAAG,IAAI,CAACI,KAAK;IAC5C;IACA;IACA;IACA,MAAMC,QAAQ,GAAG,IAAIjC,gBAAgB,CAAC;MACpCQ,KAAK;MACLE;IACF,CAAC,CAAC,CAACwB,SAAS,CAACN,MAAM,CAAC;IACpB,MAAM,EAAEO,QAAQ,EAAEC,SAAS,EAAEC,IAAI,CAAC,CAAC,GAAGJ,QAAQ;;IAE9C,IAAI,CAACK,KAAK,GAAG;MACXC,QAAQ,EAAE;QACRH,SAAS;QACTD,QAAQ;QACRE;MACF;IACF,CAAC;IACD,IAAI,CAACG,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAACC,IAAI,CAAC,IAAI,CAAC;EAClE;;EAEAD,oBAAoBA,CAACD,QAAQ,EAAE;IAC7B,IAAI,CAACG,QAAQ,CAAC,EAAEH,QAAQ,CAAC,CAAC,CAAC;IAC3B,MAAM,EAAElB,gBAAgB,CAAC,CAAC,GAAG,IAAI,CAACW,KAAK;IACvCX,gBAAgB,CAACkB,QAAQ,CAAC;EAC5B;;EAEAI,MAAMA,CAAA,EAAG;IACP,MAAM;MACJnC,KAAK;MACLE,MAAM;MACNC,cAAc;MACdE,SAAS;MACTE,aAAa;MACbG,QAAQ;MACRC,YAAY;MACZI,WAAW;MACXC,eAAe;MACfC,mBAAmB;MACnBC,GAAG;MACHV,eAAe;MACfY;IACF,CAAC,GAAG,IAAI,CAACI,KAAK;IACd,MAAM,EAAEO,QAAQ,CAAC,CAAC,GAAG,IAAI,CAACD,KAAK;IAC/B,MAAMM,UAAU;IACdL,QAAQ,CAACK,UAAU,KAAKC,SAAS,GAAG,KAAK,GAAGN,QAAQ,CAACK,UAAU;;IAEjE;IACA;IACA;IACA;IACA,MAAME,gBAAgB,GAAItC,KAAK,GAAG,GAAG,GAAI,GAAG;IAC5C,MAAMuC,cAAc,GAAIrC,MAAM,GAAG,GAAG,GAAI,GAAG;IAC3C,MAAMsC,IAAI,GAAG;IACXpB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGkB,gBAAgB;IAC/BlB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGmB,cAAc;IAC7BnB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGkB,gBAAgB;IAC/BlB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGmB,cAAc,CAC9B;;IACD,MAAME,QAAQ,GAAGpC,SAAS,CAACqC,WAAW,CAACF,IAAI,EAAEG,IAAI,CAACC,KAAK,CAACb,QAAQ,CAACF,IAAI,CAAC,CAAC;;IAEvE;MACElC,IAAA,CAACJ,KAAK;QACAwC,QAAQ;QACZrB,QAAQ,EAAEA,QAAS;QACnBV,KAAK,EAAEA,KAAM;QACbE,MAAM,EAAEA,MAAO;QACf2C,oBAAoB,EAAElC,YAAa;QACnCE,gBAAgB,EAAE,IAAI,CAACmB,oBAAqB;QAC5Cc,qBAAqB,QAAAC,QAAA;;QAErBpD,IAAA,CAACF,sBAAsB;UACjBsC,QAAQ;UACZK,UAAU,EAAEA,UAAW;UACvBY,SAAS,EAAEP,QAAS;UACpBQ,SAAS,EAAElC,WAAY;UACvBC,eAAe,EAAEA,eAAgB;UACjCE,GAAG,EAAEA,GAAI;UACTX,aAAa,EAAEA,aAAc;UAC7B2C,kBAAkB,EAAC,QAAQ;UAC3BjC,mBAAmB,EAAEA,mBAAoB;UACzCkC,WAAW,EAAE3C,eAAe,GAAGL,cAAc,GAAG,IAAK;UACrDiD,cAAc,EAAEA,CAAAC,QAAQ,KAAI;YAC1B,MAAM,EAAEC,WAAW,CAAC,CAAC,GAAGD,QAAQ,CAACE,QAAQ;;YAEzC,OAAO,CAACD,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;UACzC,CAAE;QACH,CAAC;MACG,CAAC;;EAEZ,CAAC;EAAAE,iCAAAC,GAAA,EAAAC,IAAA;IAAA,KAAAD,GAAA,IAAAE,IAAA,CAAAD,IAAA,GACH;AAEApC,MAAM,CAACvB,SAAS,GAAGA,SAAS;AAC5BuB,MAAM,CAACD,YAAY,GAAGA,YAAY,CAAC,MAAAuC,QAAA;;AAEpBtC,MAAM,CAArB,eAAAsC,QAAA,CAAsB,mBAAAC,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAA1B,SAAA,MAAAwB,cAAA,WAAAA,cAAA,CAAAG,QAAA,CAjIhBpE,IAAI,uFAAAiE,cAAA,CAAAG,QAAA,CACGnE,gBAAgB,mGAAAgE,cAAA,CAAAG,QAAA,CAChBlE,oBAAoB,uGAAA+D,cAAA,CAAAG,QAAA,CAE3BjE,SAAS,4FAAA8D,cAAA,CAAAG,QAAA,CAiBT3C,YAAY,+FAAAwC,cAAA,CAAAG,QAAA,CASZ1C,MAAM,yFAAAuC,cAAA,CAAAG,QAAA,CAAAJ,QAAA,kHAAAK,WAAA,UAAAH,oBAAA,mBAAAA,oBAAA,CAAAG,WAAA,GAAA5B,SAAA,CAAA4B,WAAA,IAAAA,WAAA,CAAAC,MAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}