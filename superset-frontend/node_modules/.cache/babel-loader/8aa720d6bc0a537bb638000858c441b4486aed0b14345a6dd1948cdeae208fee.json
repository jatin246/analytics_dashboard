{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useState, useMemo, useEffect } from 'react';\nimport rison from 'rison';\nimport { ensureIsArray, t, useChangeEffect, getClientErrorObject } from '@superset-ui/core';\nimport { Select } from 'src/components';\nimport { useToasts } from 'src/components/MessageToasts/withToasts';\nimport { cachedSupersetGet } from 'src/utils/cachedSupersetGet';\n/** Special purpose AsyncSelect that selects a column from a dataset */\n// eslint-disable-next-line import/prefer-default-export\nimport { jsx as _jsx } from \"@emotion/react/jsx-runtime\";export function ColumnSelect({ allowClear = false, filterValues = () => true, form, formField = 'column', filterId, datasetId, value, onChange, mode }) {var _form$getFieldValue;\n  const [columns, setColumns] = useState();\n  const [loading, setLoading] = useState(false);\n  const { addDangerToast } = useToasts();\n  const resetColumnField = useCallback(() => {\n    form.setFields([\n    { name: ['filters', filterId, formField], touched: false, value: null }]\n    );\n  }, [form, filterId, formField]);\n  const options = useMemo(() => ensureIsArray(columns).\n  filter(filterValues).\n  map((col) => col.column_name).\n  map((column) => ({ label: column, value: column })), [columns, filterValues]);\n  const currentFilterType = (_form$getFieldValue = form.getFieldValue('filters')) == null ? void 0 : _form$getFieldValue[filterId].filterType;\n  const currentColumn = useMemo(() => columns == null ? void 0 : columns.find((column) => column.column_name === value), [columns, value]);\n  useEffect(() => {\n    if (currentColumn && !filterValues(currentColumn)) {\n      resetColumnField();\n    }\n  }, [currentColumn, currentFilterType, resetColumnField]);\n  useChangeEffect(datasetId, (previous) => {\n    if (previous != null) {\n      setColumns([]);\n      resetColumnField();\n    }\n    if (datasetId != null) {\n      setLoading(true);\n      cachedSupersetGet({\n        endpoint: `/api/v1/dataset/${datasetId}?q=${rison.encode({\n          columns: [\n          'columns.column_name',\n          'columns.is_dttm',\n          'columns.type_generic']\n\n        })}`\n      }).\n      then(({ json: { result } }) => {\n        const lookupValue = Array.isArray(value) ? value : [value];\n        const valueExists = result.columns.some((column) => lookupValue == null ? void 0 : lookupValue.includes(column.column_name));\n        if (!valueExists) {\n          resetColumnField();\n        }\n        setColumns(result.columns);\n      }, async (badResponse) => {\n        const { error, message } = await getClientErrorObject(badResponse);\n        let errorText = message || error || t('An error has occurred');\n        if (message === 'Forbidden') {\n          errorText = t('You do not have permission to edit this dashboard');\n        }\n        addDangerToast(errorText);\n      }).\n      finally(() => setLoading(false));\n    }\n  });\n  return _jsx(Select, { mode: mode, value: mode === 'multiple' ? value || [] : value, ariaLabel: t('Column select'), loading: loading, onChange: onChange, options: options, placeholder: t('Select a column'), notFoundContent: t('No compatible columns found'), showSearch: true, allowClear: allowClear });\n}__signature__(ColumnSelect, \"useState{[columns, setColumns]}\\nuseState{[loading, setLoading](false)}\\nuseToasts{{ addDangerToast }}\\nuseCallback{resetColumnField}\\nuseMemo{options}\\nuseMemo{currentColumn}\\nuseEffect{}\\nuseChangeEffect{}\", () => [useToasts, useChangeEffect]);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(ColumnSelect, \"ColumnSelect\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/ColumnSelect.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["useCallback","useState","useMemo","useEffect","rison","ensureIsArray","t","useChangeEffect","getClientErrorObject","Select","useToasts","cachedSupersetGet","jsx","_jsx","ColumnSelect","allowClear","filterValues","form","formField","filterId","datasetId","value","onChange","mode","_form$getFieldValue","columns","setColumns","loading","setLoading","addDangerToast","resetColumnField","setFields","name","touched","options","filter","map","col","column_name","column","label","currentFilterType","getFieldValue","filterType","currentColumn","find","previous","endpoint","encode","then","json","result","lookupValue","Array","isArray","valueExists","some","includes","badResponse","error","message","errorText","finally","ariaLabel","placeholder","notFoundContent","showSearch","__signature__","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/ColumnSelect.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useState, useMemo, useEffect } from 'react';\nimport rison from 'rison';\nimport {\n  Column,\n  ensureIsArray,\n  t,\n  useChangeEffect,\n  getClientErrorObject,\n} from '@superset-ui/core';\nimport { Select, FormInstance } from 'src/components';\nimport { useToasts } from 'src/components/MessageToasts/withToasts';\nimport { cachedSupersetGet } from 'src/utils/cachedSupersetGet';\nimport { NativeFiltersForm } from '../types';\n\ninterface ColumnSelectProps {\n  allowClear?: boolean;\n  filterValues?: (column: Column) => boolean;\n  form: FormInstance<NativeFiltersForm>;\n  formField?: string;\n  filterId: string;\n  datasetId?: number;\n  value?: string | string[];\n  onChange?: (value: string) => void;\n  mode?: 'multiple';\n}\n\n/** Special purpose AsyncSelect that selects a column from a dataset */\n// eslint-disable-next-line import/prefer-default-export\nexport function ColumnSelect({\n  allowClear = false,\n  filterValues = () => true,\n  form,\n  formField = 'column',\n  filterId,\n  datasetId,\n  value,\n  onChange,\n  mode,\n}: ColumnSelectProps) {\n  const [columns, setColumns] = useState<Column[]>();\n  const [loading, setLoading] = useState(false);\n  const { addDangerToast } = useToasts();\n  const resetColumnField = useCallback(() => {\n    form.setFields([\n      { name: ['filters', filterId, formField], touched: false, value: null },\n    ]);\n  }, [form, filterId, formField]);\n\n  const options = useMemo(\n    () =>\n      ensureIsArray(columns)\n        .filter(filterValues)\n        .map((col: Column) => col.column_name)\n        .map((column: string) => ({ label: column, value: column })),\n    [columns, filterValues],\n  );\n\n  const currentFilterType =\n    form.getFieldValue('filters')?.[filterId].filterType;\n  const currentColumn = useMemo(\n    () => columns?.find(column => column.column_name === value),\n    [columns, value],\n  );\n\n  useEffect(() => {\n    if (currentColumn && !filterValues(currentColumn)) {\n      resetColumnField();\n    }\n  }, [currentColumn, currentFilterType, resetColumnField]);\n\n  useChangeEffect(datasetId, previous => {\n    if (previous != null) {\n      setColumns([]);\n      resetColumnField();\n    }\n    if (datasetId != null) {\n      setLoading(true);\n      cachedSupersetGet({\n        endpoint: `/api/v1/dataset/${datasetId}?q=${rison.encode({\n          columns: [\n            'columns.column_name',\n            'columns.is_dttm',\n            'columns.type_generic',\n          ],\n        })}`,\n      })\n        .then(\n          ({ json: { result } }) => {\n            const lookupValue = Array.isArray(value) ? value : [value];\n            const valueExists = result.columns.some(\n              (column: Column) => lookupValue?.includes(column.column_name),\n            );\n            if (!valueExists) {\n              resetColumnField();\n            }\n            setColumns(result.columns);\n          },\n          async badResponse => {\n            const { error, message } = await getClientErrorObject(badResponse);\n            let errorText = message || error || t('An error has occurred');\n            if (message === 'Forbidden') {\n              errorText = t(\n                'You do not have permission to edit this dashboard',\n              );\n            }\n            addDangerToast(errorText);\n          },\n        )\n        .finally(() => setLoading(false));\n    }\n  });\n\n  return (\n    <Select\n      mode={mode}\n      value={mode === 'multiple' ? value || [] : value}\n      ariaLabel={t('Column select')}\n      loading={loading}\n      onChange={onChange}\n      options={options}\n      placeholder={t('Select a column')}\n      notFoundContent={t('No compatible columns found')}\n      showSearch\n      allowClear={allowClear}\n    />\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}