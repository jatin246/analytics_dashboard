{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\nimport { ensureIsArray } from '../utils';\nimport { customTimeRangeDecode } from './customTimeRangeDecode';\nconst DAY_IN_MS = 24 * 60 * 60 * 1000;\nexport const parseDttmToDate = (dttm, isEndDate = false, computingShifts = false) => {\n  const now = new Date();\n  if (dttm === 'now' ||\n  dttm === 'today' ||\n  dttm === 'No filter' ||\n  dttm === '') {\n    return now;\n  }\n  if (computingShifts) {\n    now.setHours(-now.getTimezoneOffset() / 60, 0, 0, 0);\n  } else\n  {\n    now.setHours(0, 0, 0, 0);\n  }\n  if (isEndDate && dttm != null && dttm.includes('Last')) {\n    return now;\n  }\n  switch (dttm) {\n    case 'Last day':\n      now.setUTCDate(now.getUTCDate() - 1);\n      return now;\n    case 'Last week':\n      now.setUTCDate(now.getUTCDate() - 7);\n      return now;\n    case 'Last month':\n      now.setUTCMonth(now.getUTCMonth() - 1);\n      return now;\n    case 'Last quarter':\n      now.setUTCMonth(now.getUTCMonth() - 3);\n      return now;\n    case 'Last year':\n      now.setUTCFullYear(now.getUTCFullYear() - 1);\n      return now;\n    case 'previous calendar week':\n      if (isEndDate) {\n        now.setDate(now.getDate() - now.getDay() + 1); // end date is the last day of the previous week (Sunday)\n      } else\n      {\n        now.setDate(now.getDate() - now.getDay() - 6); // start date is the first day of the previous week (Monday)\n      }\n      return now;\n    case 'previous calendar month':\n      if (isEndDate) {\n        now.setDate(1); // end date is the last day of the previous month\n      } else\n      {\n        now.setDate(1); // start date is the first day of the previous month\n        now.setMonth(now.getMonth() - 1);\n      }\n      return now;\n    case 'previous calendar year':\n      if (isEndDate) {\n        now.setFullYear(now.getFullYear(), 0, 1); // end date is the last day of the previous year\n      } else\n      {\n        now.setFullYear(now.getFullYear() - 1, 0, 1); // start date is the first day of the previous year\n      }\n      return now;\n    default:\n      break;\n  }\n  if (dttm != null && dttm.includes('ago')) {\n    const parts = dttm.split(' ');\n    const amount = parseInt(parts[0], 10);\n    const unit = parts[1];\n    switch (unit) {\n      case 'day':\n      case 'days':\n        now.setUTCDate(now.getUTCDate() - amount);\n        break;\n      case 'week':\n      case 'weeks':\n        now.setUTCDate(now.getUTCDate() - amount * 7);\n        break;\n      case 'month':\n      case 'months':\n        now.setUTCMonth(now.getUTCMonth() - amount);\n        break;\n      case 'year':\n      case 'years':\n        now.setUTCFullYear(now.getUTCFullYear() - amount);\n        break;\n      default:\n        break;\n    }\n    return now;\n  }\n  const parts = dttm == null ? void 0 : dttm.split('-');\n  let parsed = null;\n  if (parts && !_isEmpty(parts)) {\n    if (parts.length === 1) {\n      parsed = new Date(Date.UTC(parseInt(parts[0], 10), 0));\n    } else\n    if (parts.length === 2) {\n      parsed = new Date(Date.UTC(parseInt(parts[0], 10), parseInt(parts[1], 10) - 1));\n    } else\n    if (parts.length === 3) {\n      parsed = new Date(parseInt(parts[0], 10), parseInt(parts[1], 10) - 1, parseInt(parts[2], 10));\n    } else\n    {\n      parsed = new Date(dttm);\n    }\n  } else\n  {\n    parsed = new Date(dttm);\n  }\n  if (parsed && !Number.isNaN(parsed.getTime())) {\n    if (computingShifts) {\n      parsed.setHours(-parsed.getTimezoneOffset() / 60, 0, 0, 0);\n    } else\n    {\n      parsed.setHours(0, 0, 0, 0);\n    }\n    return parsed;\n  }\n  // Return null if the string cannot be parsed into a date\n  return null;\n};\nexport const computeCustomDateTime = (dttm, grain, grainValue) => {\n  let parsed;\n  if (dttm === 'now' || dttm === 'today') {\n    parsed = new Date();\n  } else\n  {\n    parsed = new Date(dttm);\n  }\n  if (!Number.isNaN(parsed.getTime())) {\n    switch (grain) {\n      case 'second':\n        parsed.setSeconds(parsed.getSeconds() + grainValue);\n        break;\n      case 'minute':\n        parsed.setMinutes(parsed.getMinutes() + grainValue);\n        break;\n      case 'hour':\n        parsed.setHours(parsed.getHours() + grainValue);\n        break;\n      case 'day':\n        parsed.setDate(parsed.getDate() + grainValue);\n        break;\n      case 'week':\n        parsed.setDate(parsed.getDate() + grainValue * 7);\n        break;\n      case 'month':\n        parsed.setMonth(parsed.getMonth() + grainValue);\n        break;\n      case 'quarter':\n        parsed.setMonth(parsed.getMonth() + grainValue * 3);\n        break;\n      case 'year':\n        parsed.setFullYear(parsed.getFullYear() + grainValue);\n        break;\n      default:\n        break;\n    }\n    return parsed;\n  }\n  return null;\n};\nexport const getTimeOffset = ({ timeRangeFilter, shifts, startDate, includeFutureOffsets = true }) => {var _timeRangeFilter$comp, _timeRangeFilter$comp2, _ref, _customStartDate2, _ref2, _customEndDate2;\n  const { customRange, matchedFlag } = customTimeRangeDecode((_timeRangeFilter$comp = timeRangeFilter == null ? void 0 : timeRangeFilter.comparator) != null ? _timeRangeFilter$comp : '');\n  let customStartDate = null;\n  let customEndDate = null;\n  if (matchedFlag) {var _customStartDate, _customEndDate;\n    // Compute the start date and end date using the custom range information\n    const { sinceDatetime, sinceMode, sinceGrain, sinceGrainValue, untilDatetime, untilMode, untilGrain, untilGrainValue } = { ...customRange };\n    if (sinceMode !== 'relative') {\n      if (sinceMode === 'specific') {\n        customStartDate = new Date(sinceDatetime);\n      } else\n      {\n        customStartDate = parseDttmToDate(sinceDatetime, false, true);\n      }\n    } else\n    {\n      customStartDate = computeCustomDateTime(sinceDatetime, sinceGrain, sinceGrainValue);\n    }\n    (_customStartDate = customStartDate) == null ? void 0 : _customStartDate.setHours(0, 0, 0, 0);\n    if (untilMode !== 'relative') {\n      if (untilMode === 'specific') {\n        customEndDate = new Date(untilDatetime);\n      } else\n      {\n        customEndDate = parseDttmToDate(untilDatetime, false, true);\n      }\n    } else\n    {\n      customEndDate = computeCustomDateTime(untilDatetime, untilGrain, untilGrainValue);\n    }\n    (_customEndDate = customEndDate) == null ? void 0 : _customEndDate.setHours(0, 0, 0, 0);\n  }\n  const isCustom = shifts == null ? void 0 : shifts.includes('custom');\n  const isInherit = shifts == null ? void 0 : shifts.includes('inherit');\n  let customStartDateTime;\n  if (isCustom) {\n    if (matchedFlag) {\n      customStartDateTime = new Date(new Date(startDate).setUTCHours(new Date(startDate).getTimezoneOffset() / 60, 0, 0, 0)).getTime();\n    } else\n    {var _parseDttmToDate;\n      customStartDateTime = (_parseDttmToDate = parseDttmToDate(startDate)) == null ? void 0 : _parseDttmToDate.getTime();\n    }\n  }\n  const [startStr, endStr] = ((_timeRangeFilter$comp2 = timeRangeFilter == null ? void 0 : timeRangeFilter.comparator) != null ? _timeRangeFilter$comp2 : '').\n  split(' : ').\n  map((date) => date.trim());\n  const filterStartDateTime = ((_ref = (_customStartDate2 = customStartDate) != null ? _customStartDate2 : parseDttmToDate(startStr, false, false)) == null ? void 0 : _ref.getTime()) ||\n  0;\n  const filterEndDateTime = ((_ref2 = (_customEndDate2 = customEndDate) != null ? _customEndDate2 : parseDttmToDate(endStr || startStr, true, false)) == null ? void 0 : _ref2.getTime()) || 0;\n  const customShift = customStartDateTime &&\n  Math.round((filterStartDateTime - customStartDateTime) / DAY_IN_MS);\n  const inInheritShift = isInherit &&\n  Math.round((filterEndDateTime - filterStartDateTime) / DAY_IN_MS);\n  const newShifts = ensureIsArray(shifts).\n  map((shift) => {\n    if (shift === 'custom') {\n      if (customShift !== undefined && !Number.isNaN(customShift)) {\n        if (includeFutureOffsets && customShift < 0) {\n          return `${customShift * -1} days after`;\n        }\n        if (customShift >= 0) {\n          return `${customShift} days ago`;\n        }\n      }\n    }\n    if (shift === 'inherit') {\n      if (inInheritShift && !Number.isNaN(inInheritShift)) {\n        if (includeFutureOffsets && inInheritShift < 0) {\n          return `${inInheritShift * -1} days after`;\n        }\n        if (inInheritShift > 0) {\n          return `${inInheritShift} days ago`;\n        }\n      }\n    }\n    return shift;\n  }).\n  filter((shift) => shift !== 'custom' && shift !== 'inherit');\n  return ensureIsArray(newShifts);\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(DAY_IN_MS, \"DAY_IN_MS\", \"/app/superset-frontend/packages/superset-ui-core/src/time-comparison/getTimeOffset.ts\");reactHotLoader.register(parseDttmToDate, \"parseDttmToDate\", \"/app/superset-frontend/packages/superset-ui-core/src/time-comparison/getTimeOffset.ts\");reactHotLoader.register(computeCustomDateTime, \"computeCustomDateTime\", \"/app/superset-frontend/packages/superset-ui-core/src/time-comparison/getTimeOffset.ts\");reactHotLoader.register(getTimeOffset, \"getTimeOffset\", \"/app/superset-frontend/packages/superset-ui-core/src/time-comparison/getTimeOffset.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["enterModule","reactHotLoaderGlobal","undefined","module","__signature__","default","signature","a","ensureIsArray","customTimeRangeDecode","DAY_IN_MS","parseDttmToDate","dttm","isEndDate","computingShifts","now","Date","setHours","getTimezoneOffset","includes","setUTCDate","getUTCDate","setUTCMonth","getUTCMonth","setUTCFullYear","getUTCFullYear","setDate","getDate","getDay","setMonth","getMonth","setFullYear","getFullYear","parts","split","amount","parseInt","unit","parsed","_isEmpty","length","UTC","Number","isNaN","getTime","computeCustomDateTime","grain","grainValue","setSeconds","getSeconds","setMinutes","getMinutes","getHours","getTimeOffset","timeRangeFilter","shifts","startDate","includeFutureOffsets","_timeRangeFilter$comp","_timeRangeFilter$comp2","_ref","_customStartDate2","_ref2","_customEndDate2","customRange","matchedFlag","comparator","customStartDate","customEndDate","_customStartDate","_customEndDate","sinceDatetime","sinceMode","sinceGrain","sinceGrainValue","untilDatetime","untilMode","untilGrain","untilGrainValue","isCustom","isInherit","customStartDateTime","setUTCHours","_parseDttmToDate","startStr","endStr","map","date","trim","filterStartDateTime","filterEndDateTime","customShift","Math","round","inInheritShift","newShifts","shift","filter","reactHotLoader","register","leaveModule"],"sources":["/app/superset-frontend/packages/superset-ui-core/src/time-comparison/getTimeOffset.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isEmpty } from 'lodash';\nimport { ensureIsArray } from '../utils';\nimport { customTimeRangeDecode } from './customTimeRangeDecode';\n\nconst DAY_IN_MS = 24 * 60 * 60 * 1000;\nexport const parseDttmToDate = (\n  dttm: string,\n  isEndDate = false,\n  computingShifts = false,\n) => {\n  const now = new Date();\n  if (\n    dttm === 'now' ||\n    dttm === 'today' ||\n    dttm === 'No filter' ||\n    dttm === ''\n  ) {\n    return now;\n  }\n\n  if (computingShifts) {\n    now.setHours(-now.getTimezoneOffset() / 60, 0, 0, 0);\n  } else {\n    now.setHours(0, 0, 0, 0);\n  }\n\n  if (isEndDate && dttm?.includes('Last')) {\n    return now;\n  }\n\n  switch (dttm) {\n    case 'Last day':\n      now.setUTCDate(now.getUTCDate() - 1);\n      return now;\n    case 'Last week':\n      now.setUTCDate(now.getUTCDate() - 7);\n      return now;\n    case 'Last month':\n      now.setUTCMonth(now.getUTCMonth() - 1);\n      return now;\n    case 'Last quarter':\n      now.setUTCMonth(now.getUTCMonth() - 3);\n      return now;\n    case 'Last year':\n      now.setUTCFullYear(now.getUTCFullYear() - 1);\n      return now;\n    case 'previous calendar week':\n      if (isEndDate) {\n        now.setDate(now.getDate() - now.getDay() + 1); // end date is the last day of the previous week (Sunday)\n      } else {\n        now.setDate(now.getDate() - now.getDay() - 6); // start date is the first day of the previous week (Monday)\n      }\n      return now;\n    case 'previous calendar month':\n      if (isEndDate) {\n        now.setDate(1); // end date is the last day of the previous month\n      } else {\n        now.setDate(1); // start date is the first day of the previous month\n        now.setMonth(now.getMonth() - 1);\n      }\n      return now;\n    case 'previous calendar year':\n      if (isEndDate) {\n        now.setFullYear(now.getFullYear(), 0, 1); // end date is the last day of the previous year\n      } else {\n        now.setFullYear(now.getFullYear() - 1, 0, 1); // start date is the first day of the previous year\n      }\n      return now;\n    default:\n      break;\n  }\n  if (dttm?.includes('ago')) {\n    const parts = dttm.split(' ');\n    const amount = parseInt(parts[0], 10);\n    const unit = parts[1];\n    switch (unit) {\n      case 'day':\n      case 'days':\n        now.setUTCDate(now.getUTCDate() - amount);\n        break;\n      case 'week':\n      case 'weeks':\n        now.setUTCDate(now.getUTCDate() - amount * 7);\n        break;\n      case 'month':\n      case 'months':\n        now.setUTCMonth(now.getUTCMonth() - amount);\n        break;\n      case 'year':\n      case 'years':\n        now.setUTCFullYear(now.getUTCFullYear() - amount);\n        break;\n      default:\n        break;\n    }\n    return now;\n  }\n  const parts = dttm?.split('-');\n  let parsed: Date | null = null;\n  if (parts && !isEmpty(parts)) {\n    if (parts.length === 1) {\n      parsed = new Date(Date.UTC(parseInt(parts[0], 10), 0));\n    } else if (parts.length === 2) {\n      parsed = new Date(\n        Date.UTC(parseInt(parts[0], 10), parseInt(parts[1], 10) - 1),\n      );\n    } else if (parts.length === 3) {\n      parsed = new Date(\n        parseInt(parts[0], 10),\n        parseInt(parts[1], 10) - 1,\n        parseInt(parts[2], 10),\n      );\n    } else {\n      parsed = new Date(dttm);\n    }\n  } else {\n    parsed = new Date(dttm);\n  }\n  if (parsed && !Number.isNaN(parsed.getTime())) {\n    if (computingShifts) {\n      parsed.setHours(-parsed.getTimezoneOffset() / 60, 0, 0, 0);\n    } else {\n      parsed.setHours(0, 0, 0, 0);\n    }\n    return parsed;\n  }\n  // Return null if the string cannot be parsed into a date\n  return null;\n};\n\nexport const computeCustomDateTime = (\n  dttm: string,\n  grain: string,\n  grainValue: number,\n) => {\n  let parsed: Date;\n  if (dttm === 'now' || dttm === 'today') {\n    parsed = new Date();\n  } else {\n    parsed = new Date(dttm);\n  }\n  if (!Number.isNaN(parsed.getTime())) {\n    switch (grain) {\n      case 'second':\n        parsed.setSeconds(parsed.getSeconds() + grainValue);\n        break;\n      case 'minute':\n        parsed.setMinutes(parsed.getMinutes() + grainValue);\n        break;\n      case 'hour':\n        parsed.setHours(parsed.getHours() + grainValue);\n        break;\n      case 'day':\n        parsed.setDate(parsed.getDate() + grainValue);\n        break;\n      case 'week':\n        parsed.setDate(parsed.getDate() + grainValue * 7);\n        break;\n      case 'month':\n        parsed.setMonth(parsed.getMonth() + grainValue);\n        break;\n      case 'quarter':\n        parsed.setMonth(parsed.getMonth() + grainValue * 3);\n        break;\n      case 'year':\n        parsed.setFullYear(parsed.getFullYear() + grainValue);\n        break;\n      default:\n        break;\n    }\n    return parsed;\n  }\n  return null;\n};\n\ntype TimeOffsetArgs = {\n  timeRangeFilter: any;\n  shifts: string[];\n  startDate: string;\n  includeFutureOffsets?: boolean;\n};\n\nexport const getTimeOffset = ({\n  timeRangeFilter,\n  shifts,\n  startDate,\n  includeFutureOffsets = true,\n}: TimeOffsetArgs): string[] => {\n  const { customRange, matchedFlag } = customTimeRangeDecode(\n    timeRangeFilter?.comparator ?? '',\n  );\n  let customStartDate: Date | null = null;\n  let customEndDate: Date | null = null;\n  if (matchedFlag) {\n    // Compute the start date and end date using the custom range information\n    const {\n      sinceDatetime,\n      sinceMode,\n      sinceGrain,\n      sinceGrainValue,\n      untilDatetime,\n      untilMode,\n      untilGrain,\n      untilGrainValue,\n    } = { ...customRange };\n    if (sinceMode !== 'relative') {\n      if (sinceMode === 'specific') {\n        customStartDate = new Date(sinceDatetime);\n      } else {\n        customStartDate = parseDttmToDate(sinceDatetime, false, true);\n      }\n    } else {\n      customStartDate = computeCustomDateTime(\n        sinceDatetime,\n        sinceGrain,\n        sinceGrainValue,\n      );\n    }\n    customStartDate?.setHours(0, 0, 0, 0);\n    if (untilMode !== 'relative') {\n      if (untilMode === 'specific') {\n        customEndDate = new Date(untilDatetime);\n      } else {\n        customEndDate = parseDttmToDate(untilDatetime, false, true);\n      }\n    } else {\n      customEndDate = computeCustomDateTime(\n        untilDatetime,\n        untilGrain,\n        untilGrainValue,\n      );\n    }\n    customEndDate?.setHours(0, 0, 0, 0);\n  }\n  const isCustom = shifts?.includes('custom');\n  const isInherit = shifts?.includes('inherit');\n  let customStartDateTime: number | undefined;\n  if (isCustom) {\n    if (matchedFlag) {\n      customStartDateTime = new Date(\n        new Date(startDate).setUTCHours(\n          new Date(startDate).getTimezoneOffset() / 60,\n          0,\n          0,\n          0,\n        ),\n      ).getTime();\n    } else {\n      customStartDateTime = parseDttmToDate(startDate)?.getTime();\n    }\n  }\n  const [startStr, endStr] = (timeRangeFilter?.comparator ?? '')\n    .split(' : ')\n    .map((date: string) => date.trim());\n  const filterStartDateTime =\n    (customStartDate ?? parseDttmToDate(startStr, false, false))?.getTime() ||\n    0;\n  const filterEndDateTime =\n    (\n      customEndDate ?? parseDttmToDate(endStr || startStr, true, false)\n    )?.getTime() || 0;\n\n  const customShift =\n    customStartDateTime &&\n    Math.round((filterStartDateTime - customStartDateTime) / DAY_IN_MS);\n  const inInheritShift =\n    isInherit &&\n    Math.round((filterEndDateTime - filterStartDateTime) / DAY_IN_MS);\n\n  const newShifts = ensureIsArray(shifts)\n    .map(shift => {\n      if (shift === 'custom') {\n        if (customShift !== undefined && !Number.isNaN(customShift)) {\n          if (includeFutureOffsets && customShift < 0) {\n            return `${customShift * -1} days after`;\n          }\n          if (customShift >= 0) {\n            return `${customShift} days ago`;\n          }\n        }\n      }\n      if (shift === 'inherit') {\n        if (inInheritShift && !Number.isNaN(inInheritShift)) {\n          if (includeFutureOffsets && inInheritShift < 0) {\n            return `${inInheritShift * -1} days after`;\n          }\n          if (inInheritShift > 0) {\n            return `${inInheritShift} days ago`;\n          }\n        }\n      }\n      return shift;\n    })\n    .filter(shift => shift !== 'custom' && shift !== 'inherit');\n  return ensureIsArray(newShifts);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}