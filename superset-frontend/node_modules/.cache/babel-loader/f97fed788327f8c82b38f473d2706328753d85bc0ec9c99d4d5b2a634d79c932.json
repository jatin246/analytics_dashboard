{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getCategoricalSchemeRegistry, getLabelsColorMap } from '@superset-ui/core';\n/**\n * Forces falsy namespace values to undefined to default to GLOBAL\n *\n * @param namespace\n * @returns - namespace or default undefined\n */\nexport const getColorNamespace = (namespace) => namespace || undefined;\n/**\n * Get the labels color map entries\n *\n * @returns Record<string, string>\n */\nexport const getLabelsColorMapEntries = () => {\n  const labelsColorMapInstance = getLabelsColorMap();\n  const updatedLabelsColorMapEntries = Object.fromEntries(labelsColorMapInstance.getColorMap());\n  return updatedLabelsColorMapEntries;\n};\nexport const getColorSchemeDomain = (colorScheme) => {var _getCategoricalScheme;return ((_getCategoricalScheme = getCategoricalSchemeRegistry().get(colorScheme)) == null ? void 0 : _getCategoricalScheme.colors) || [];};\n/**\n * Compare the current labels color map with a fresh one\n *\n * @param currentLabelsColorMap - the current labels color map\n * @returns true if the labels color map is the same as fresh\n */\nexport const isLabelsColorMapSynced = (metadata) => {\n  const currentLabelsColorMap = (metadata == null ? void 0 : metadata.shared_label_colors) || {};\n  const customLabelColors = (metadata == null ? void 0 : metadata.label_colors) || {};\n  const freshLabelsColorMap = getLabelsColorMap().getColorMap();\n  const isSynced = Array.from(freshLabelsColorMap.entries()).every(([label, color]) => currentLabelsColorMap.hasOwnProperty(label) && (\n  currentLabelsColorMap[label] === color ||\n  customLabelColors[label] !== undefined));\n  return isSynced;\n};\n/**\n * Annihilate color maps\n *\n * @param color_namespace - the categorical namespace\n */\nexport const resetColors = (color_namespace) => {\n  const labelsColorMapInstance = getLabelsColorMap();\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(getColorNamespace(color_namespace));\n  categoricalNamespace.resetColors();\n  labelsColorMapInstance.clear();\n};\n/**\n * Update the labels color map based on current color scheme\n * It will respect custom label colors if set via namespace\n *\n * @param namespace - the color namespace\n * @param colorScheme - the current color scheme\n */\nexport const refreshLabelsColorMap = (namespace, colorScheme) => {\n  const colorNameSpace = getColorNamespace(namespace);\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(colorNameSpace);\n  const labelsColorMapInstance = getLabelsColorMap();\n  labelsColorMapInstance.updateColorMap(categoricalNamespace, colorScheme);\n};\n/**\n * Merge labels colors with custom labels colors\n * Apply labels color based on chosen color scheme\n *\n * @param metadata - the dashboard metadata object\n */\nexport const applyColors = (metadata, fresh = false) => {\n  const colorNameSpace = getColorNamespace(metadata == null ? void 0 : metadata.color_namespace);\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(colorNameSpace);\n  const colorScheme = metadata == null ? void 0 : metadata.color_scheme;\n  const customLabelColors = (metadata == null ? void 0 : metadata.label_colors) || {};\n  // when scheme unset, update only custom label colors\n  const labelsColorMap = (metadata == null ? void 0 : metadata.shared_label_colors) || {};\n  // reset forced colors (custom labels + labels color map)\n  categoricalNamespace.resetColors();\n  // apply custom label colors first\n  Object.keys(customLabelColors).forEach((label) => {\n    categoricalNamespace.setColor(label, customLabelColors[label]);\n  });\n  // re-instantiate a fresh labels color map based on current scheme\n  // will consider also just applied custom label colors\n  refreshLabelsColorMap(metadata == null ? void 0 : metadata.color_namespace, colorScheme);\n  // get the fresh map that was just updated or existing\n  const labelsColorMapEntries = fresh ?\n  getLabelsColorMapEntries() :\n  labelsColorMap;\n  // apply the final color map\n  Object.keys(labelsColorMapEntries).forEach((label) => {\n    categoricalNamespace.setColor(label, labelsColorMapEntries[label]);\n  });\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getColorNamespace, \"getColorNamespace\", \"/app/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(getLabelsColorMapEntries, \"getLabelsColorMapEntries\", \"/app/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(getColorSchemeDomain, \"getColorSchemeDomain\", \"/app/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(isLabelsColorMapSynced, \"isLabelsColorMapSynced\", \"/app/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(resetColors, \"resetColors\", \"/app/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(refreshLabelsColorMap, \"refreshLabelsColorMap\", \"/app/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(applyColors, \"applyColors\", \"/app/superset-frontend/src/utils/colorScheme.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["CategoricalColorNamespace","getCategoricalSchemeRegistry","getLabelsColorMap","getColorNamespace","namespace","undefined","getLabelsColorMapEntries","labelsColorMapInstance","updatedLabelsColorMapEntries","Object","fromEntries","getColorMap","getColorSchemeDomain","colorScheme","_getCategoricalScheme","get","colors","isLabelsColorMapSynced","metadata","currentLabelsColorMap","shared_label_colors","customLabelColors","label_colors","freshLabelsColorMap","isSynced","Array","from","entries","every","label","color","hasOwnProperty","resetColors","color_namespace","categoricalNamespace","getNamespace","clear","refreshLabelsColorMap","colorNameSpace","updateColorMap","applyColors","fresh","color_scheme","labelsColorMap","keys","forEach","setColor","labelsColorMapEntries","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/app/superset-frontend/src/utils/colorScheme.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport {\n  CategoricalColorNamespace,\n  getCategoricalSchemeRegistry,\n  getLabelsColorMap,\n} from '@superset-ui/core';\n\n/**\n * Forces falsy namespace values to undefined to default to GLOBAL\n *\n * @param namespace\n * @returns - namespace or default undefined\n */\nexport const getColorNamespace = (namespace?: string) => namespace || undefined;\n\n/**\n * Get the labels color map entries\n *\n * @returns Record<string, string>\n */\nexport const getLabelsColorMapEntries = (): Record<string, string> => {\n  const labelsColorMapInstance = getLabelsColorMap();\n  const updatedLabelsColorMapEntries = Object.fromEntries(\n    labelsColorMapInstance.getColorMap(),\n  );\n  return updatedLabelsColorMapEntries;\n};\n\nexport const getColorSchemeDomain = (colorScheme: string) =>\n  getCategoricalSchemeRegistry().get(colorScheme)?.colors || [];\n\n/**\n * Compare the current labels color map with a fresh one\n *\n * @param currentLabelsColorMap - the current labels color map\n * @returns true if the labels color map is the same as fresh\n */\nexport const isLabelsColorMapSynced = (\n  metadata: Record<string, any>,\n): boolean => {\n  const currentLabelsColorMap = metadata?.shared_label_colors || {};\n  const customLabelColors = metadata?.label_colors || {};\n  const freshLabelsColorMap = getLabelsColorMap().getColorMap();\n  const isSynced = Array.from(freshLabelsColorMap.entries()).every(\n    ([label, color]) =>\n      currentLabelsColorMap.hasOwnProperty(label) &&\n      (currentLabelsColorMap[label] === color ||\n        customLabelColors[label] !== undefined),\n  );\n  return isSynced;\n};\n\n/**\n * Annihilate color maps\n *\n * @param color_namespace - the categorical namespace\n */\nexport const resetColors = (color_namespace?: string) => {\n  const labelsColorMapInstance = getLabelsColorMap();\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(\n    getColorNamespace(color_namespace),\n  );\n  categoricalNamespace.resetColors();\n  labelsColorMapInstance.clear();\n};\n\n/**\n * Update the labels color map based on current color scheme\n * It will respect custom label colors if set via namespace\n *\n * @param namespace - the color namespace\n * @param colorScheme - the current color scheme\n */\nexport const refreshLabelsColorMap = (\n  namespace?: string,\n  colorScheme?: string,\n) => {\n  const colorNameSpace = getColorNamespace(namespace);\n  const categoricalNamespace =\n    CategoricalColorNamespace.getNamespace(colorNameSpace);\n  const labelsColorMapInstance = getLabelsColorMap();\n\n  labelsColorMapInstance.updateColorMap(categoricalNamespace, colorScheme);\n};\n\n/**\n * Merge labels colors with custom labels colors\n * Apply labels color based on chosen color scheme\n *\n * @param metadata - the dashboard metadata object\n */\nexport const applyColors = (metadata: Record<string, any>, fresh = false) => {\n  const colorNameSpace = getColorNamespace(metadata?.color_namespace);\n  const categoricalNamespace =\n    CategoricalColorNamespace.getNamespace(colorNameSpace);\n  const colorScheme = metadata?.color_scheme;\n  const customLabelColors = metadata?.label_colors || {};\n  // when scheme unset, update only custom label colors\n  const labelsColorMap = metadata?.shared_label_colors || {};\n\n  // reset forced colors (custom labels + labels color map)\n  categoricalNamespace.resetColors();\n\n  // apply custom label colors first\n  Object.keys(customLabelColors).forEach(label => {\n    categoricalNamespace.setColor(label, customLabelColors[label]);\n  });\n\n  // re-instantiate a fresh labels color map based on current scheme\n  // will consider also just applied custom label colors\n  refreshLabelsColorMap(metadata?.color_namespace, colorScheme);\n\n  // get the fresh map that was just updated or existing\n  const labelsColorMapEntries = fresh\n    ? getLabelsColorMapEntries()\n    : labelsColorMap;\n\n  // apply the final color map\n  Object.keys(labelsColorMapEntries).forEach(label => {\n    categoricalNamespace.setColor(label, labelsColorMapEntries[label]);\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}