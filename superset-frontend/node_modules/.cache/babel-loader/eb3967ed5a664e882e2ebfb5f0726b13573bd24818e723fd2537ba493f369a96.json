{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { buildQueryContext, ensureIsArray, getMetricLabel, getTimeOffset, isPhysicalColumn, parseDttmToDate, QueryMode, removeDuplicates } from '@superset-ui/core';\nimport { isTimeComparison, timeCompareOperator } from '@superset-ui/chart-controls';\n\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\n/**\n * Infer query mode from form data. If `all_columns` is set, then raw records mode,\n * otherwise defaults to aggregation mode.\n *\n * The same logic is used in `controlPanel` with control values as well.\n */\nexport function getQueryMode(formData) {\n  const { query_mode: mode } = formData;\n  if (mode === QueryMode.Aggregate || mode === QueryMode.Raw) {\n    return mode;\n  }\n  const rawColumns = formData == null ? void 0 : formData.all_columns;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.Raw : QueryMode.Aggregate;\n}\nconst buildQuery = (formData, options) => {\n  const { percent_metrics: percentMetrics, order_desc: orderDesc = false, extra_form_data } = formData;\n  const queryMode = getQueryMode(formData);\n  const sortByMetric = ensureIsArray(formData.timeseries_limit_metric)[0];\n  const time_grain_sqla = (extra_form_data == null ? void 0 : extra_form_data.time_grain_sqla) || formData.time_grain_sqla;\n  let formDataCopy = formData;\n  // never include time in raw records mode\n  if (queryMode === QueryMode.Raw) {\n    formDataCopy = {\n      ...formData,\n      include_time: false\n    };\n  }\n  const addComparisonPercentMetrics = (metrics, suffixes) => metrics.reduce((acc, metric) => {\n    const newMetrics = suffixes.map((suffix) => `${metric}__${suffix}`);\n    return acc.concat([metric, ...newMetrics]);\n  }, []);\n  return buildQueryContext(formDataCopy, (baseQueryObject) => {var _formData$adhoc_filte, _formData$adhoc_custo, _previousCustomTimeRa, _baseQueryObject$time, _TimeRangeFilters$, _parseDttmToDate, _options$ownState, _options$extras, _options$extras$cache, _options$extras2, _options$extras2$cach, _options$hooks2, _metrics2, _formData$extra_form_;\n    let { metrics, orderby = [], columns = [] } = baseQueryObject;\n    const { extras = {} } = baseQueryObject;\n    let postProcessing = [];\n    const TimeRangeFilters = ((_formData$adhoc_filte = formData.adhoc_filters) == null ? void 0 : _formData$adhoc_filte.filter((filter) => filter.operator === 'TEMPORAL_RANGE')) || [];\n    // In case the viz is using all version of controls, we try to load them\n    const previousCustomTimeRangeFilters = ((_formData$adhoc_custo = formData.adhoc_custom) == null ? void 0 : _formData$adhoc_custo.filter((filter) => filter.operator === 'TEMPORAL_RANGE')) || [];\n    let previousCustomStartDate = '';\n    if (!_isEmpty(previousCustomTimeRangeFilters) &&\n    ((_previousCustomTimeRa = previousCustomTimeRangeFilters[0]) == null ? void 0 : _previousCustomTimeRa.comparator) !== 'No Filter') {var _previousCustomTimeRa2;\n      previousCustomStartDate = (_previousCustomTimeRa2 =\n      previousCustomTimeRangeFilters[0]) == null ? void 0 : _previousCustomTimeRa2.comparator.split(' : ')[0];\n    }\n    const timeOffsets = ensureIsArray(isTimeComparison(formData, baseQueryObject) ?\n    getTimeOffset({\n      timeRangeFilter: {\n        ...TimeRangeFilters[0],\n        comparator: (_baseQueryObject$time = baseQueryObject == null ? void 0 : baseQueryObject.time_range) != null ? _baseQueryObject$time : (_TimeRangeFilters$ =\n        TimeRangeFilters[0]) == null ? void 0 : _TimeRangeFilters$.comparator\n      },\n      shifts: formData.time_compare,\n      startDate: previousCustomStartDate && !formData.start_date_offset ? (_parseDttmToDate =\n      parseDttmToDate(previousCustomStartDate)) == null ? void 0 : _parseDttmToDate.toUTCString() :\n      formData.start_date_offset\n    }) :\n    []);\n    let temporalColumAdded = false;\n    let temporalColum = null;\n    if (queryMode === QueryMode.Aggregate) {var _metrics;\n      metrics = metrics || [];\n      // override orderby with timeseries metric when in aggregation mode\n      if (sortByMetric) {\n        orderby = [[sortByMetric, !orderDesc]];\n      } else\n      if (((_metrics = metrics) == null ? void 0 : _metrics.length) > 0) {\n        // default to ordering by first metric in descending order\n        // when no \"sort by\" metric is set (regardless if \"SORT DESC\" is set to true)\n        orderby = [[metrics[0], false]];\n      }\n      // add postprocessing for percent metrics only when in aggregation mode\n      if (percentMetrics && percentMetrics.length > 0) {\n        const percentMetricsLabelsWithTimeComparison = isTimeComparison(formData, baseQueryObject) ?\n        addComparisonPercentMetrics(percentMetrics.map(getMetricLabel), timeOffsets) :\n        percentMetrics.map(getMetricLabel);\n        const percentMetricLabels = removeDuplicates(percentMetricsLabelsWithTimeComparison);\n        metrics = removeDuplicates(metrics.concat(percentMetrics), getMetricLabel);\n        postProcessing = [\n        {\n          operation: 'contribution',\n          options: {\n            columns: percentMetricLabels,\n            rename_columns: percentMetricLabels.map((x) => `%${x}`)\n          }\n        }];\n\n      }\n      // Add the operator for the time comparison if some is selected\n      if (!_isEmpty(timeOffsets)) {\n        postProcessing.push(timeCompareOperator(formData, baseQueryObject));\n      }\n      const temporalColumnsLookup = formData == null ? void 0 : formData.temporal_columns_lookup;\n      // Filter out the column if needed and prepare the temporal column object\n      columns = columns.filter((col) => {\n        const shouldBeAdded = isPhysicalColumn(col) &&\n        time_grain_sqla && (\n        temporalColumnsLookup == null ? void 0 : temporalColumnsLookup[col]);\n        if (shouldBeAdded && !temporalColumAdded) {\n          temporalColum = {\n            timeGrain: time_grain_sqla,\n            columnType: 'BASE_AXIS',\n            sqlExpression: col,\n            label: col,\n            expressionType: 'SQL'\n          };\n          temporalColumAdded = true;\n          return false; // Do not include this in the output; it's added separately\n        }\n        return true;\n      });\n      // So we ensure the temporal column is added first\n      if (temporalColum) {\n        columns = [temporalColum, ...columns];\n      }\n    }\n    const moreProps = {};\n    const ownState = (_options$ownState = options == null ? void 0 : options.ownState) != null ? _options$ownState : {};\n    if (formDataCopy.server_pagination) {var _ownState$pageSize, _ownState$currentPage, _ownState$pageSize2;\n      moreProps.row_limit = (_ownState$pageSize =\n      ownState.pageSize) != null ? _ownState$pageSize : formDataCopy.server_page_length;\n      moreProps.row_offset =\n      ((_ownState$currentPage = ownState.currentPage) != null ? _ownState$currentPage : 0) * ((_ownState$pageSize2 = ownState.pageSize) != null ? _ownState$pageSize2 : 0);\n    }\n    let queryObject = {\n      ...baseQueryObject,\n      columns,\n      extras: !_isEmpty(timeOffsets) && !temporalColum ? {} : extras,\n      orderby,\n      metrics,\n      post_processing: postProcessing,\n      time_offsets: timeOffsets,\n      ...moreProps\n    };\n    if (formData.server_pagination &&\n    options != null && (_options$extras = options.extras) != null && (_options$extras$cache = _options$extras.cachedChanges) != null && _options$extras$cache[formData.slice_id] &&\n    JSON.stringify(options == null ? void 0 : (_options$extras2 = options.extras) == null ? void 0 : (_options$extras2$cach = _options$extras2.cachedChanges) == null ? void 0 : _options$extras2$cach[formData.slice_id]) !==\n    JSON.stringify(queryObject.filters)) {var _options$hooks, _queryObject$row_limi;\n      queryObject = { ...queryObject, row_offset: 0 };\n      updateExternalFormData(options == null ? void 0 : (_options$hooks = options.hooks) == null ? void 0 : _options$hooks.setDataMask, 0, (_queryObject$row_limi = queryObject.row_limit) != null ? _queryObject$row_limi : 0);\n    }\n    // Because we use same buildQuery for all table on the page we need split them by id\n    options == null ? void 0 : (_options$hooks2 = options.hooks) == null ? void 0 : _options$hooks2.setCachedChanges({\n      [formData.slice_id]: queryObject.filters\n    });\n    const extraQueries = [];\n    if ((_metrics2 = metrics) != null && _metrics2.length &&\n    formData.show_totals &&\n    queryMode === QueryMode.Aggregate) {\n      extraQueries.push({\n        ...queryObject,\n        columns: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        extras: undefined,\n        order_desc: undefined,\n        orderby: undefined // because this query will be used for get total aggregation.\n      });\n    }\n    const interactiveGroupBy = (_formData$extra_form_ = formData.extra_form_data) == null ? void 0 : _formData$extra_form_.interactive_groupby;\n    if (interactiveGroupBy && queryObject.columns) {\n      queryObject.columns = [\n      ...new Set([...queryObject.columns, ...interactiveGroupBy])];\n\n    }\n    if (formData.server_pagination) {\n      return [\n      { ...queryObject },\n      {\n        ...queryObject,\n        time_offsets: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        is_rowcount: true\n      },\n      ...extraQueries];\n\n    }\n    return [queryObject, ...extraQueries];\n  });\n};\n// Use this closure to cache changing of external filters, if we have server pagination we need reset page to 0, after\n// external filter changed\nexport const cachedBuildQuery = () => {\n  let cachedChanges = {};\n  const setCachedChanges = (newChanges) => {\n    cachedChanges = { ...cachedChanges, ...newChanges };\n  };\n  return (formData, options) => {var _options$ownState2;return buildQuery({ ...formData }, {\n      extras: { cachedChanges },\n      ownState: (_options$ownState2 = options == null ? void 0 : options.ownState) != null ? _options$ownState2 : {},\n      hooks: {\n        ...(options == null ? void 0 : options.hooks),\n        setDataMask: () => {},\n        setCachedChanges\n      }\n    });};\n};const _default =\ncachedBuildQuery();export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getQueryMode, \"getQueryMode\", \"/app/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(buildQuery, \"buildQuery\", \"/app/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(cachedBuildQuery, \"cachedBuildQuery\", \"/app/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["buildQueryContext","ensureIsArray","getMetricLabel","getTimeOffset","isPhysicalColumn","parseDttmToDate","QueryMode","removeDuplicates","isTimeComparison","timeCompareOperator","updateExternalFormData","getQueryMode","formData","query_mode","mode","Aggregate","Raw","rawColumns","all_columns","hasRawColumns","length","buildQuery","options","percent_metrics","percentMetrics","order_desc","orderDesc","extra_form_data","queryMode","sortByMetric","timeseries_limit_metric","time_grain_sqla","formDataCopy","include_time","addComparisonPercentMetrics","metrics","suffixes","reduce","acc","metric","newMetrics","map","suffix","concat","baseQueryObject","_formData$adhoc_filte","_formData$adhoc_custo","_previousCustomTimeRa","_baseQueryObject$time","_TimeRangeFilters$","_parseDttmToDate","_options$ownState","_options$extras","_options$extras$cache","_options$extras2","_options$extras2$cach","_options$hooks2","_metrics2","_formData$extra_form_","orderby","columns","extras","postProcessing","TimeRangeFilters","adhoc_filters","filter","operator","previousCustomTimeRangeFilters","adhoc_custom","previousCustomStartDate","_isEmpty","comparator","_previousCustomTimeRa2","split","timeOffsets","timeRangeFilter","time_range","shifts","time_compare","startDate","start_date_offset","toUTCString","temporalColumAdded","temporalColum","_metrics","percentMetricsLabelsWithTimeComparison","percentMetricLabels","operation","rename_columns","x","push","temporalColumnsLookup","temporal_columns_lookup","col","shouldBeAdded","timeGrain","columnType","sqlExpression","label","expressionType","moreProps","ownState","server_pagination","_ownState$pageSize","_ownState$currentPage","_ownState$pageSize2","row_limit","pageSize","server_page_length","row_offset","currentPage","queryObject","post_processing","time_offsets","cachedChanges","slice_id","JSON","stringify","filters","_options$hooks","_queryObject$row_limi","hooks","setDataMask","setCachedChanges","extraQueries","show_totals","undefined","interactiveGroupBy","interactive_groupby","Set","is_rowcount","cachedBuildQuery","newChanges","_options$ownState2","_default","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/app/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AdhocColumn,\n  buildQueryContext,\n  ensureIsArray,\n  getMetricLabel,\n  getTimeOffset,\n  isPhysicalColumn,\n  parseDttmToDate,\n  QueryMode,\n  QueryObject,\n  removeDuplicates,\n  SimpleAdhocFilter,\n} from '@superset-ui/core';\nimport { PostProcessingRule } from '@superset-ui/core/src/query/types/PostProcessing';\nimport { BuildQuery } from '@superset-ui/core/src/chart/registries/ChartBuildQueryRegistrySingleton';\nimport {\n  isTimeComparison,\n  timeCompareOperator,\n} from '@superset-ui/chart-controls';\nimport { isEmpty } from 'lodash';\nimport { TableChartFormData } from './types';\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\n\n/**\n * Infer query mode from form data. If `all_columns` is set, then raw records mode,\n * otherwise defaults to aggregation mode.\n *\n * The same logic is used in `controlPanel` with control values as well.\n */\nexport function getQueryMode(formData: TableChartFormData) {\n  const { query_mode: mode } = formData;\n  if (mode === QueryMode.Aggregate || mode === QueryMode.Raw) {\n    return mode;\n  }\n  const rawColumns = formData?.all_columns;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.Raw : QueryMode.Aggregate;\n}\n\nconst buildQuery: BuildQuery<TableChartFormData> = (\n  formData: TableChartFormData,\n  options,\n) => {\n  const {\n    percent_metrics: percentMetrics,\n    order_desc: orderDesc = false,\n    extra_form_data,\n  } = formData;\n  const queryMode = getQueryMode(formData);\n  const sortByMetric = ensureIsArray(formData.timeseries_limit_metric)[0];\n  const time_grain_sqla =\n    extra_form_data?.time_grain_sqla || formData.time_grain_sqla;\n  let formDataCopy = formData;\n  // never include time in raw records mode\n  if (queryMode === QueryMode.Raw) {\n    formDataCopy = {\n      ...formData,\n      include_time: false,\n    };\n  }\n\n  const addComparisonPercentMetrics = (metrics: string[], suffixes: string[]) =>\n    metrics.reduce<string[]>((acc, metric) => {\n      const newMetrics = suffixes.map(suffix => `${metric}__${suffix}`);\n      return acc.concat([metric, ...newMetrics]);\n    }, []);\n\n  return buildQueryContext(formDataCopy, baseQueryObject => {\n    let { metrics, orderby = [], columns = [] } = baseQueryObject;\n    const { extras = {} } = baseQueryObject;\n    let postProcessing: PostProcessingRule[] = [];\n    const TimeRangeFilters =\n      formData.adhoc_filters?.filter(\n        (filter: SimpleAdhocFilter) => filter.operator === 'TEMPORAL_RANGE',\n      ) || [];\n\n    // In case the viz is using all version of controls, we try to load them\n    const previousCustomTimeRangeFilters: any =\n      formData.adhoc_custom?.filter(\n        (filter: SimpleAdhocFilter) => filter.operator === 'TEMPORAL_RANGE',\n      ) || [];\n\n    let previousCustomStartDate = '';\n    if (\n      !isEmpty(previousCustomTimeRangeFilters) &&\n      previousCustomTimeRangeFilters[0]?.comparator !== 'No Filter'\n    ) {\n      previousCustomStartDate =\n        previousCustomTimeRangeFilters[0]?.comparator.split(' : ')[0];\n    }\n\n    const timeOffsets = ensureIsArray(\n      isTimeComparison(formData, baseQueryObject)\n        ? getTimeOffset({\n            timeRangeFilter: {\n              ...TimeRangeFilters[0],\n              comparator:\n                baseQueryObject?.time_range ??\n                (TimeRangeFilters[0] as any)?.comparator,\n            },\n            shifts: formData.time_compare,\n            startDate:\n              previousCustomStartDate && !formData.start_date_offset\n                ? parseDttmToDate(previousCustomStartDate)?.toUTCString()\n                : formData.start_date_offset,\n          })\n        : [],\n    );\n\n    let temporalColumAdded = false;\n    let temporalColum = null;\n\n    if (queryMode === QueryMode.Aggregate) {\n      metrics = metrics || [];\n      // override orderby with timeseries metric when in aggregation mode\n      if (sortByMetric) {\n        orderby = [[sortByMetric, !orderDesc]];\n      } else if (metrics?.length > 0) {\n        // default to ordering by first metric in descending order\n        // when no \"sort by\" metric is set (regardless if \"SORT DESC\" is set to true)\n        orderby = [[metrics[0], false]];\n      }\n      // add postprocessing for percent metrics only when in aggregation mode\n      if (percentMetrics && percentMetrics.length > 0) {\n        const percentMetricsLabelsWithTimeComparison = isTimeComparison(\n          formData,\n          baseQueryObject,\n        )\n          ? addComparisonPercentMetrics(\n              percentMetrics.map(getMetricLabel),\n              timeOffsets,\n            )\n          : percentMetrics.map(getMetricLabel);\n        const percentMetricLabels = removeDuplicates(\n          percentMetricsLabelsWithTimeComparison,\n        );\n        metrics = removeDuplicates(\n          metrics.concat(percentMetrics),\n          getMetricLabel,\n        );\n        postProcessing = [\n          {\n            operation: 'contribution',\n            options: {\n              columns: percentMetricLabels,\n              rename_columns: percentMetricLabels.map(x => `%${x}`),\n            },\n          },\n        ];\n      }\n      // Add the operator for the time comparison if some is selected\n      if (!isEmpty(timeOffsets)) {\n        postProcessing.push(timeCompareOperator(formData, baseQueryObject));\n      }\n\n      const temporalColumnsLookup = formData?.temporal_columns_lookup;\n      // Filter out the column if needed and prepare the temporal column object\n\n      columns = columns.filter(col => {\n        const shouldBeAdded =\n          isPhysicalColumn(col) &&\n          time_grain_sqla &&\n          temporalColumnsLookup?.[col];\n\n        if (shouldBeAdded && !temporalColumAdded) {\n          temporalColum = {\n            timeGrain: time_grain_sqla,\n            columnType: 'BASE_AXIS',\n            sqlExpression: col,\n            label: col,\n            expressionType: 'SQL',\n          } as AdhocColumn;\n          temporalColumAdded = true;\n          return false; // Do not include this in the output; it's added separately\n        }\n        return true;\n      });\n\n      // So we ensure the temporal column is added first\n      if (temporalColum) {\n        columns = [temporalColum, ...columns];\n      }\n    }\n\n    const moreProps: Partial<QueryObject> = {};\n    const ownState = options?.ownState ?? {};\n    if (formDataCopy.server_pagination) {\n      moreProps.row_limit =\n        ownState.pageSize ?? formDataCopy.server_page_length;\n      moreProps.row_offset =\n        (ownState.currentPage ?? 0) * (ownState.pageSize ?? 0);\n    }\n\n    let queryObject = {\n      ...baseQueryObject,\n      columns,\n      extras: !isEmpty(timeOffsets) && !temporalColum ? {} : extras,\n      orderby,\n      metrics,\n      post_processing: postProcessing,\n      time_offsets: timeOffsets,\n      ...moreProps,\n    };\n\n    if (\n      formData.server_pagination &&\n      options?.extras?.cachedChanges?.[formData.slice_id] &&\n      JSON.stringify(options?.extras?.cachedChanges?.[formData.slice_id]) !==\n        JSON.stringify(queryObject.filters)\n    ) {\n      queryObject = { ...queryObject, row_offset: 0 };\n      updateExternalFormData(\n        options?.hooks?.setDataMask,\n        0,\n        queryObject.row_limit ?? 0,\n      );\n    }\n    // Because we use same buildQuery for all table on the page we need split them by id\n    options?.hooks?.setCachedChanges({\n      [formData.slice_id]: queryObject.filters,\n    });\n\n    const extraQueries: QueryObject[] = [];\n    if (\n      metrics?.length &&\n      formData.show_totals &&\n      queryMode === QueryMode.Aggregate\n    ) {\n      extraQueries.push({\n        ...queryObject,\n        columns: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        extras: undefined, // we don't need time grain here\n        order_desc: undefined, // we don't need orderby stuff here,\n        orderby: undefined, // because this query will be used for get total aggregation.\n      });\n    }\n\n    const interactiveGroupBy = formData.extra_form_data?.interactive_groupby;\n    if (interactiveGroupBy && queryObject.columns) {\n      queryObject.columns = [\n        ...new Set([...queryObject.columns, ...interactiveGroupBy]),\n      ];\n    }\n\n    if (formData.server_pagination) {\n      return [\n        { ...queryObject },\n        {\n          ...queryObject,\n          time_offsets: [],\n          row_limit: 0,\n          row_offset: 0,\n          post_processing: [],\n          is_rowcount: true,\n        },\n        ...extraQueries,\n      ];\n    }\n\n    return [queryObject, ...extraQueries];\n  });\n};\n\n// Use this closure to cache changing of external filters, if we have server pagination we need reset page to 0, after\n// external filter changed\nexport const cachedBuildQuery = (): BuildQuery<TableChartFormData> => {\n  let cachedChanges: any = {};\n  const setCachedChanges = (newChanges: any) => {\n    cachedChanges = { ...cachedChanges, ...newChanges };\n  };\n\n  return (formData, options) =>\n    buildQuery(\n      { ...formData },\n      {\n        extras: { cachedChanges },\n        ownState: options?.ownState ?? {},\n        hooks: {\n          ...options?.hooks,\n          setDataMask: () => {},\n          setCachedChanges,\n        },\n      },\n    );\n};\n\nexport default cachedBuildQuery();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}