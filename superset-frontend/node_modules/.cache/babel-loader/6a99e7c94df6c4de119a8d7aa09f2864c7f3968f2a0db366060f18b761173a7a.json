{"ast":null,"code":"import _pick from \"lodash/pick\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { LabelsColorMapSource, getLabelsColorMap } from '@superset-ui/core';\nimport { ParentSize } from '@visx/responsive';\n\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport { DASHBOARD_GRID_ID, DASHBOARD_ROOT_DEPTH } from 'src/dashboard/util/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/getChartIdsInFilterScope';\nimport findTabIndexByComponentId from 'src/dashboard/util/findTabIndexByComponentId';\nimport { setInScopeStatusOfFilters } from 'src/dashboard/actions/nativeFilters';\nimport { updateDashboardLabelsColor } from 'src/dashboard/actions/dashboardState';\nimport { applyColors, getColorNamespace, resetColors } from 'src/utils/colorScheme';\nimport { NATIVE_FILTER_DIVIDER_PREFIX } from '../nativeFilters/FiltersConfigModal/utils';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { getRootLevelTabsComponent } from './utils';import { Fragment as _Fragment, jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nconst useNativeFilterScopes = () => {\n  const nativeFilters = useSelector((state) => {var _state$nativeFilters;return (_state$nativeFilters = state.nativeFilters) == null ? void 0 : _state$nativeFilters.filters;});\n  return useMemo(() => nativeFilters ?\n  Object.values(nativeFilters).map((filter) => _pick(filter, ['id', 'scope', 'type'])) :\n  [], [JSON.stringify(nativeFilters)]);\n};__signature__(useNativeFilterScopes, \"useSelector{nativeFilters}\\nuseMemo{}\", () => [useSelector]);\nconst DashboardContainer = ({ topLevelTabs }) => {\n  const nativeFilterScopes = useNativeFilterScopes();\n  const dispatch = useDispatch();\n  const dashboardLayout = useSelector((state) => state.dashboardLayout.present);\n  const dashboardInfo = useSelector((state) => state.dashboardInfo);\n  const directPathToChild = useSelector((state) => state.dashboardState.directPathToChild);\n  const chartIds = useSelector((state) => Object.values(state.charts).map((chart) => chart.id));\n  const prevTabIndexRef = useRef();\n  const tabIndex = useMemo(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild\n    });\n    if (nextTabIndex === -1) {var _prevTabIndexRef$curr;\n      return (_prevTabIndexRef$curr = prevTabIndexRef.current) != null ? _prevTabIndexRef$curr : 0;\n    }\n    prevTabIndexRef.current = nextTabIndex;\n    return nextTabIndex;\n  }, [dashboardLayout, directPathToChild]);\n  useEffect(() => {\n    if (nativeFilterScopes.length === 0) {\n      return;\n    }\n    const scopes = nativeFilterScopes.map((filterScope) => {\n      if (filterScope.id.startsWith(NATIVE_FILTER_DIVIDER_PREFIX)) {\n        return {\n          filterId: filterScope.id,\n          tabsInScope: [],\n          chartsInScope: []\n        };\n      }\n      const chartsInScope = getChartIdsInFilterScope(filterScope.scope, chartIds, dashboardLayout);\n      const tabsInScope = findTabsWithChartsInScope(dashboardLayout, chartsInScope);\n      return {\n        filterId: filterScope.id,\n        tabsInScope: Array.from(tabsInScope),\n        chartsInScope\n      };\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [nativeFilterScopes, dashboardLayout, dispatch]);\n  const childIds = topLevelTabs ?\n  topLevelTabs.children :\n  [DASHBOARD_GRID_ID];\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n  const TOP_OF_PAGE_RANGE = 220;\n  useEffect(() => {\n    // verify freshness of color map on tab change\n    // and when loading for first time\n    setTimeout(() => {\n      dispatch(updateDashboardLabelsColor());\n    }, 500);\n  }, [directPathToChild, dispatch]);\n  useEffect(() => {var _dashboardInfo$metada;\n    const labelsColorMap = getLabelsColorMap();\n    const colorNamespace = getColorNamespace(dashboardInfo == null ? void 0 : (_dashboardInfo$metada = dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada.color_namespace);\n    labelsColorMap.source = LabelsColorMapSource.Dashboard;\n    // apply labels color as dictated by stored metadata\n    applyColors(dashboardInfo.metadata);\n    return () => {\n      resetColors(getColorNamespace(colorNamespace));\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dashboardInfo.id, dispatch]);\n  return _jsx(\"div\", { className: \"grid-container\", \"data-test\": \"grid-container\", children:\n    _jsx(ParentSize, { children:\n      ({ width }) =>\n      /*\n        We use a TabContainer irrespective of whether top-level tabs exist to maintain\n        a consistent React component tree. This avoids expensive mounts/unmounts of\n        the entire dashboard upon adding/removing top-level tabs, which would otherwise\n        happen because of React's diffing algorithm\n      */\n      _jsx(Tabs, { id: DASHBOARD_GRID_ID, activeKey: activeKey, renderTabBar: () => _jsx(_Fragment, {}), fullWidth: false, animated: false, allowOverflow: true, onFocus: (e) => {\n          if (\n          // prevent scrolling when tabbing to the tab pane\n          e.target.classList.contains('ant-tabs-tabpane') &&\n          window.scrollY < TOP_OF_PAGE_RANGE) {\n            // prevent window from jumping down when tabbing\n            // if already at the top of the page\n            // to help with accessibility when using keyboard navigation\n            window.scrollTo(window.scrollX, 0);\n          }\n        }, children:\n        childIds.map((id, index) =>\n        // Matching the key of the first TabPane irrespective of topLevelTabs\n        // lets us keep the same React component tree when !!topLevelTabs changes.\n        // This avoids expensive mounts/unmounts of the entire dashboard.\n        _jsx(Tabs.TabPane, { children:\n          _jsx(DashboardGrid, { gridComponent: dashboardLayout[id]\n            // see isValidChild for why tabs do not increment the depth of their children\n            , depth: DASHBOARD_ROOT_DEPTH + 1 // (topLevelTabs ? 0 : 1)}\n            , width: width, isComponentVisible: index === tabIndex }) }, index === 0 ? DASHBOARD_GRID_ID : index.toString()\n        )) }\n      ) }\n    ) }\n  );\n};__signature__(DashboardContainer, \"useNativeFilterScopes{nativeFilterScopes}\\nuseDispatch{dispatch}\\nuseSelector{dashboardLayout}\\nuseSelector{dashboardInfo}\\nuseSelector{directPathToChild}\\nuseSelector{chartIds}\\nuseRef{prevTabIndexRef}\\nuseMemo{tabIndex}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\", () => [useNativeFilterScopes, useDispatch, useSelector, useSelector, useSelector, useSelector]);const _default =\nDashboardContainer;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(useNativeFilterScopes, \"useNativeFilterScopes\", \"/app/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(DashboardContainer, \"DashboardContainer\", \"/app/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["useEffect","useMemo","useRef","useDispatch","useSelector","LabelsColorMapSource","getLabelsColorMap","ParentSize","Tabs","DashboardGrid","DASHBOARD_GRID_ID","DASHBOARD_ROOT_DEPTH","getChartIdsInFilterScope","findTabIndexByComponentId","setInScopeStatusOfFilters","updateDashboardLabelsColor","applyColors","getColorNamespace","resetColors","NATIVE_FILTER_DIVIDER_PREFIX","findTabsWithChartsInScope","getRootLevelTabsComponent","Fragment","_Fragment","jsx","_jsx","useNativeFilterScopes","nativeFilters","state","_state$nativeFilters","filters","Object","values","map","filter","_pick","JSON","stringify","__signature__","DashboardContainer","topLevelTabs","nativeFilterScopes","dispatch","dashboardLayout","present","dashboardInfo","directPathToChild","dashboardState","chartIds","charts","chart","id","prevTabIndexRef","tabIndex","nextTabIndex","currentComponent","_prevTabIndexRef$curr","current","length","scopes","filterScope","startsWith","filterId","tabsInScope","chartsInScope","scope","Array","from","childIds","children","min","Math","activeKey","toString","TOP_OF_PAGE_RANGE","setTimeout","_dashboardInfo$metada","labelsColorMap","colorNamespace","metadata","color_namespace","source","Dashboard","className","width","renderTabBar","fullWidth","animated","allowOverflow","onFocus","e","target","classList","contains","window","scrollY","scrollTo","scrollX","index","TabPane","gridComponent","depth","isComponentVisible","_default","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/app/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport { FC, useEffect, useMemo, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport {\n  Filter,\n  Filters,\n  LabelsColorMapSource,\n  getLabelsColorMap,\n} from '@superset-ui/core';\nimport { ParentSize } from '@visx/responsive';\nimport { pick } from 'lodash';\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport {\n  DashboardInfo,\n  DashboardLayout,\n  LayoutItem,\n  RootState,\n} from 'src/dashboard/types';\nimport {\n  DASHBOARD_GRID_ID,\n  DASHBOARD_ROOT_DEPTH,\n} from 'src/dashboard/util/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/getChartIdsInFilterScope';\nimport findTabIndexByComponentId from 'src/dashboard/util/findTabIndexByComponentId';\nimport { setInScopeStatusOfFilters } from 'src/dashboard/actions/nativeFilters';\nimport { updateDashboardLabelsColor } from 'src/dashboard/actions/dashboardState';\nimport {\n  applyColors,\n  getColorNamespace,\n  resetColors,\n} from 'src/utils/colorScheme';\nimport { NATIVE_FILTER_DIVIDER_PREFIX } from '../nativeFilters/FiltersConfigModal/utils';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { getRootLevelTabsComponent } from './utils';\n\ntype DashboardContainerProps = {\n  topLevelTabs?: LayoutItem;\n};\n\nconst useNativeFilterScopes = () => {\n  const nativeFilters = useSelector<RootState, Filters>(\n    state => state.nativeFilters?.filters,\n  );\n  return useMemo(\n    () =>\n      nativeFilters\n        ? Object.values(nativeFilters).map((filter: Filter) =>\n            pick(filter, ['id', 'scope', 'type']),\n          )\n        : [],\n    [JSON.stringify(nativeFilters)],\n  );\n};\n\nconst DashboardContainer: FC<DashboardContainerProps> = ({ topLevelTabs }) => {\n  const nativeFilterScopes = useNativeFilterScopes();\n  const dispatch = useDispatch();\n\n  const dashboardLayout = useSelector<RootState, DashboardLayout>(\n    state => state.dashboardLayout.present,\n  );\n  const dashboardInfo = useSelector<RootState, DashboardInfo>(\n    state => state.dashboardInfo,\n  );\n  const directPathToChild = useSelector<RootState, string[]>(\n    state => state.dashboardState.directPathToChild,\n  );\n  const chartIds = useSelector<RootState, number[]>(state =>\n    Object.values(state.charts).map(chart => chart.id),\n  );\n\n  const prevTabIndexRef = useRef();\n  const tabIndex = useMemo(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild,\n    });\n\n    if (nextTabIndex === -1) {\n      return prevTabIndexRef.current ?? 0;\n    }\n    prevTabIndexRef.current = nextTabIndex;\n    return nextTabIndex;\n  }, [dashboardLayout, directPathToChild]);\n\n  useEffect(() => {\n    if (nativeFilterScopes.length === 0) {\n      return;\n    }\n    const scopes = nativeFilterScopes.map(filterScope => {\n      if (filterScope.id.startsWith(NATIVE_FILTER_DIVIDER_PREFIX)) {\n        return {\n          filterId: filterScope.id,\n          tabsInScope: [],\n          chartsInScope: [],\n        };\n      }\n      const chartsInScope: number[] = getChartIdsInFilterScope(\n        filterScope.scope,\n        chartIds,\n        dashboardLayout,\n      );\n      const tabsInScope = findTabsWithChartsInScope(\n        dashboardLayout,\n        chartsInScope,\n      );\n      return {\n        filterId: filterScope.id,\n        tabsInScope: Array.from(tabsInScope),\n        chartsInScope,\n      };\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [nativeFilterScopes, dashboardLayout, dispatch]);\n\n  const childIds: string[] = topLevelTabs\n    ? topLevelTabs.children\n    : [DASHBOARD_GRID_ID];\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n  const TOP_OF_PAGE_RANGE = 220;\n\n  useEffect(() => {\n    // verify freshness of color map on tab change\n    // and when loading for first time\n    setTimeout(() => {\n      dispatch(updateDashboardLabelsColor());\n    }, 500);\n  }, [directPathToChild, dispatch]);\n\n  useEffect(() => {\n    const labelsColorMap = getLabelsColorMap();\n    const colorNamespace = getColorNamespace(\n      dashboardInfo?.metadata?.color_namespace,\n    );\n    labelsColorMap.source = LabelsColorMapSource.Dashboard;\n    // apply labels color as dictated by stored metadata\n    applyColors(dashboardInfo.metadata);\n\n    return () => {\n      resetColors(getColorNamespace(colorNamespace));\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dashboardInfo.id, dispatch]);\n\n  return (\n    <div className=\"grid-container\" data-test=\"grid-container\">\n      <ParentSize>\n        {({ width }) => (\n          /*\n            We use a TabContainer irrespective of whether top-level tabs exist to maintain\n            a consistent React component tree. This avoids expensive mounts/unmounts of\n            the entire dashboard upon adding/removing top-level tabs, which would otherwise\n            happen because of React's diffing algorithm\n          */\n          <Tabs\n            id={DASHBOARD_GRID_ID}\n            activeKey={activeKey}\n            renderTabBar={() => <></>}\n            fullWidth={false}\n            animated={false}\n            allowOverflow\n            onFocus={e => {\n              if (\n                // prevent scrolling when tabbing to the tab pane\n                e.target.classList.contains('ant-tabs-tabpane') &&\n                window.scrollY < TOP_OF_PAGE_RANGE\n              ) {\n                // prevent window from jumping down when tabbing\n                // if already at the top of the page\n                // to help with accessibility when using keyboard navigation\n                window.scrollTo(window.scrollX, 0);\n              }\n            }}\n          >\n            {childIds.map((id, index) => (\n              // Matching the key of the first TabPane irrespective of topLevelTabs\n              // lets us keep the same React component tree when !!topLevelTabs changes.\n              // This avoids expensive mounts/unmounts of the entire dashboard.\n              <Tabs.TabPane\n                key={index === 0 ? DASHBOARD_GRID_ID : index.toString()}\n              >\n                <DashboardGrid\n                  gridComponent={dashboardLayout[id]}\n                  // see isValidChild for why tabs do not increment the depth of their children\n                  depth={DASHBOARD_ROOT_DEPTH + 1} // (topLevelTabs ? 0 : 1)}\n                  width={width}\n                  isComponentVisible={index === tabIndex}\n                />\n              </Tabs.TabPane>\n            ))}\n          </Tabs>\n        )}\n      </ParentSize>\n    </div>\n  );\n};\n\nexport default DashboardContainer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}