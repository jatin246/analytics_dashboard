{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { COMMON_ERR_MESSAGES, t, ErrorTypeEnum, isProbablyHTML, isJsonString } from '@superset-ui/core';\nconst ERROR_CODE_LOOKUP = {\n  400: 'Bad request',\n  401: 'Unauthorized',\n  402: 'Payment required',\n  403: 'Forbidden',\n  404: 'Not found',\n  405: 'Method not allowed',\n  406: 'Not acceptable',\n  407: 'Proxy authentication required',\n  408: 'Request timeout',\n  409: 'Conflict',\n  410: 'Gone',\n  411: 'Length required',\n  412: 'Precondition failed',\n  413: 'Payload too large',\n  414: 'URI too long',\n  415: 'Unsupported media type',\n  416: 'Range not satisfiable',\n  417: 'Expectation failed',\n  418: \"I'm a teapot\",\n  500: 'Server error',\n  501: 'Not implemented',\n  502: 'Bad gateway',\n  503: 'Service unavailable',\n  504: 'Gateway timeout',\n  505: 'HTTP version not supported',\n  506: 'Variant also negotiates',\n  507: 'Insufficient storage',\n  508: 'Loop detected',\n  510: 'Not extended',\n  511: 'Network authentication required',\n  599: 'Network error'\n};\nexport function checkForHtml(str) {\n  return !isJsonString(str) && isProbablyHTML(str);\n}\nexport function parseStringResponse(str) {\n  if (checkForHtml(str)) {\n    for (const [code, message] of Object.entries(ERROR_CODE_LOOKUP)) {\n      const regex = new RegExp(`${code}|${message}`, 'i');\n      if (regex.test(str)) {\n        return t(message);\n      }\n    }\n    return t('Unknown error');\n  }\n  return str;\n}\nexport function getErrorFromStatusCode(status) {\n  return ERROR_CODE_LOOKUP[status] || null;\n}\nexport function retrieveErrorMessage(str, errorObject) {\n  const statusError = 'status' in errorObject ? getErrorFromStatusCode(errorObject.status) : null;\n  // Prefer status code message over the response or HTML text\n  return statusError || parseStringResponse(str);\n}\nexport function parseErrorJson(responseJson) {\n  let error = { ...responseJson };\n  // Backwards compatibility for old error renderers with the new error object\n  if (error.errors && error.errors.length > 0) {var _error$errors$, _error$errors$$extra;\n    error.error = error.description = error.errors[0].message;\n    error.link = (_error$errors$ = error.errors[0]) == null ? void 0 : (_error$errors$$extra = _error$errors$.extra) == null ? void 0 : _error$errors$$extra.link;\n  }\n  // Marshmallow field validation returns the error message in the format\n  // of { message: { field1: [msg1, msg2], field2: [msg], } }\n  if (!error.error && error.message) {\n    if (typeof error.message === 'object') {var _Object$values$;\n      error.error =\n      ((_Object$values$ = Object.values(error.message)[0]) == null ? void 0 : _Object$values$[0]) ||\n      t('Invalid input');\n    }\n    if (typeof error.message === 'string') {\n      if (checkForHtml(error.message)) {\n        error.error = retrieveErrorMessage(error.message, error);\n      } else\n      {\n        error.error = error.message;\n      }\n    }\n  }\n  if (error.stack) {\n    error = {\n      ...error,\n      error: t('Unexpected error: ') + (\n      error.description || t('(no description, click to see stack trace)')),\n      stacktrace: error.stack\n    };\n  } else\n  if (error.responseText && error.responseText.indexOf('CSRF') >= 0) {\n    error = {\n      ...error,\n      error: t(COMMON_ERR_MESSAGES.SESSION_TIMED_OUT)\n    };\n  }\n  return { ...error, error: error.error }; // explicit ClientErrorObject\n}\nexport function getClientErrorObject(response) {\n  // takes a SupersetClientResponse as input, attempts to read response as Json\n  // if possible, and returns a Promise that resolves to a plain object with\n  // error key and text value.\n  return new Promise((resolve) => {\n    if (typeof response === 'string') {\n      resolve({ error: parseStringResponse(response) });\n      return;\n    }\n    if (response instanceof TypeError &&\n    response.message === 'Failed to fetch') {\n      resolve({\n        error: t('Network error')\n      });\n      return;\n    }\n    if ('timeout' in response &&\n    'statusText' in response &&\n    response.statusText === 'timeout') {\n      resolve({\n        ...response,\n        error: t('Request timed out'),\n        errors: [\n        {\n          error_type: ErrorTypeEnum.FRONTEND_TIMEOUT_ERROR,\n          extra: {\n            timeout: response.timeout / 1000,\n            issue_codes: [\n            {\n              code: 1000,\n              message: t('Issue 1000 - The dataset is too large to query.')\n            },\n            {\n              code: 1001,\n              message: t('Issue 1001 - The database is under an unusual load.')\n            }]\n\n          },\n          level: 'error',\n          message: 'Request timed out'\n        }]\n\n      });\n      return;\n    }\n    const responseObject = response instanceof Response ? response : response.response;\n    if (responseObject && !responseObject.bodyUsed) {\n      // attempt to read the body as json, and fallback to text. we must clone\n      // the response in order to fallback to .text() because Response is\n      // single-read\n      responseObject.\n      clone().\n      json().\n      then((errorJson) => {\n        // Destructuring instead of spreading to avoid loss of sibling properties to the body\n        const { url, status, statusText, redirected, type } = responseObject;\n        const responseSummary = { url, status, statusText, redirected, type };\n        const error = {\n          ...errorJson,\n          ...responseSummary\n        };\n        resolve(parseErrorJson(error));\n      }).\n      catch(() => {\n        // fall back to reading as text\n        responseObject.text().then((errorText) => {\n          resolve({\n            // Destructuring not necessary here\n            ...responseObject,\n            error: retrieveErrorMessage(errorText, responseObject)\n          });\n        });\n      });\n      return;\n    }\n    // fall back to Response.statusText or generic error of we cannot read the response\n    let error = response.statusText || response.message;\n    if (!error) {\n      // eslint-disable-next-line no-console\n      console.error('non-standard error:', response);\n      error = t('An error occurred');\n    }\n    resolve({\n      ...responseObject,\n      error: parseStringResponse(error)\n    });\n  });\n}\n/*\n * Utility to get standardized error text for generic update failures\n */\nexport async function getErrorText(errorObject, source) {\n  const { error, message } = await getClientErrorObject(errorObject);\n  let errorText = t('Sorry, an unknown error occurred.');\n  if (error) {\n    errorText = t('Sorry, there was an error saving this %s: %s', source, error);\n  }\n  if (typeof message === 'string' && message === 'Forbidden') {\n    errorText = t('You do not have permission to edit this %s', source);\n  }\n  return errorText;\n}\nexport function getClientErrorMessage(message, clientError) {\n  let finalMessage = message;\n  const errorMessage = (clientError == null ? void 0 : clientError.message) || (clientError == null ? void 0 : clientError.error);\n  if (errorMessage) {\n    finalMessage = `${finalMessage}:\\n${errorMessage}`;\n  }\n  return finalMessage;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(ERROR_CODE_LOOKUP, \"ERROR_CODE_LOOKUP\", \"/app/superset-frontend/packages/superset-ui-core/src/query/getClientErrorObject.ts\");reactHotLoader.register(checkForHtml, \"checkForHtml\", \"/app/superset-frontend/packages/superset-ui-core/src/query/getClientErrorObject.ts\");reactHotLoader.register(parseStringResponse, \"parseStringResponse\", \"/app/superset-frontend/packages/superset-ui-core/src/query/getClientErrorObject.ts\");reactHotLoader.register(getErrorFromStatusCode, \"getErrorFromStatusCode\", \"/app/superset-frontend/packages/superset-ui-core/src/query/getClientErrorObject.ts\");reactHotLoader.register(retrieveErrorMessage, \"retrieveErrorMessage\", \"/app/superset-frontend/packages/superset-ui-core/src/query/getClientErrorObject.ts\");reactHotLoader.register(parseErrorJson, \"parseErrorJson\", \"/app/superset-frontend/packages/superset-ui-core/src/query/getClientErrorObject.ts\");reactHotLoader.register(getClientErrorObject, \"getClientErrorObject\", \"/app/superset-frontend/packages/superset-ui-core/src/query/getClientErrorObject.ts\");reactHotLoader.register(getErrorText, \"getErrorText\", \"/app/superset-frontend/packages/superset-ui-core/src/query/getClientErrorObject.ts\");reactHotLoader.register(getClientErrorMessage, \"getClientErrorMessage\", \"/app/superset-frontend/packages/superset-ui-core/src/query/getClientErrorObject.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["COMMON_ERR_MESSAGES","t","ErrorTypeEnum","isProbablyHTML","isJsonString","ERROR_CODE_LOOKUP","checkForHtml","str","parseStringResponse","code","message","Object","entries","regex","RegExp","test","getErrorFromStatusCode","status","retrieveErrorMessage","errorObject","statusError","parseErrorJson","responseJson","error","errors","length","_error$errors$","_error$errors$$extra","description","link","extra","_Object$values$","values","stack","stacktrace","responseText","indexOf","SESSION_TIMED_OUT","getClientErrorObject","response","Promise","resolve","TypeError","statusText","error_type","FRONTEND_TIMEOUT_ERROR","timeout","issue_codes","level","responseObject","Response","bodyUsed","clone","json","then","errorJson","url","redirected","type","responseSummary","catch","text","errorText","console","getErrorText","source","getClientErrorMessage","clientError","finalMessage","errorMessage","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/app/superset-frontend/packages/superset-ui-core/src/query/getClientErrorObject.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  COMMON_ERR_MESSAGES,\n  JsonObject,\n  SupersetClientResponse,\n  t,\n  SupersetError,\n  ErrorTypeEnum,\n  isProbablyHTML,\n  isJsonString,\n} from '@superset-ui/core';\n\n// The response always contains an error attribute, can contain anything from\n// the SupersetClientResponse object, and can contain a spread JSON blob\nexport type ClientErrorObject = {\n  error: string;\n  errors?: SupersetError[];\n  link?: string;\n  message?: string;\n  severity?: string;\n  stacktrace?: string;\n  statusText?: string;\n} & Partial<SupersetClientResponse>;\n\n// see rejectAfterTimeout.ts\ninterface TimeoutError {\n  statusText: 'timeout';\n  timeout: number;\n}\n\ntype ErrorType =\n  | SupersetClientResponse\n  | TimeoutError\n  | { response: Response }\n  | string;\n\ntype ErrorTextSource = 'dashboard' | 'chart' | 'query' | 'dataset' | 'database';\n\nconst ERROR_CODE_LOOKUP = {\n  400: 'Bad request',\n  401: 'Unauthorized',\n  402: 'Payment required',\n  403: 'Forbidden',\n  404: 'Not found',\n  405: 'Method not allowed',\n  406: 'Not acceptable',\n  407: 'Proxy authentication required',\n  408: 'Request timeout',\n  409: 'Conflict',\n  410: 'Gone',\n  411: 'Length required',\n  412: 'Precondition failed',\n  413: 'Payload too large',\n  414: 'URI too long',\n  415: 'Unsupported media type',\n  416: 'Range not satisfiable',\n  417: 'Expectation failed',\n  418: \"I'm a teapot\",\n  500: 'Server error',\n  501: 'Not implemented',\n  502: 'Bad gateway',\n  503: 'Service unavailable',\n  504: 'Gateway timeout',\n  505: 'HTTP version not supported',\n  506: 'Variant also negotiates',\n  507: 'Insufficient storage',\n  508: 'Loop detected',\n  510: 'Not extended',\n  511: 'Network authentication required',\n  599: 'Network error',\n};\n\nexport function checkForHtml(str: string): boolean {\n  return !isJsonString(str) && isProbablyHTML(str);\n}\n\nexport function parseStringResponse(str: string): string {\n  if (checkForHtml(str)) {\n    for (const [code, message] of Object.entries(ERROR_CODE_LOOKUP)) {\n      const regex = new RegExp(`${code}|${message}`, 'i');\n      if (regex.test(str)) {\n        return t(message);\n      }\n    }\n    return t('Unknown error');\n  }\n  return str;\n}\n\nexport function getErrorFromStatusCode(status: number): string | null {\n  return ERROR_CODE_LOOKUP[status] || null;\n}\n\nexport function retrieveErrorMessage(\n  str: string,\n  errorObject: JsonObject,\n): string {\n  const statusError =\n    'status' in errorObject ? getErrorFromStatusCode(errorObject.status) : null;\n\n  // Prefer status code message over the response or HTML text\n  return statusError || parseStringResponse(str);\n}\n\nexport function parseErrorJson(responseJson: JsonObject): ClientErrorObject {\n  let error = { ...responseJson };\n  // Backwards compatibility for old error renderers with the new error object\n  if (error.errors && error.errors.length > 0) {\n    error.error = error.description = error.errors[0].message;\n    error.link = error.errors[0]?.extra?.link;\n  }\n  // Marshmallow field validation returns the error message in the format\n  // of { message: { field1: [msg1, msg2], field2: [msg], } }\n  if (!error.error && error.message) {\n    if (typeof error.message === 'object') {\n      error.error =\n        Object.values(error.message as Record<string, string[]>)[0]?.[0] ||\n        t('Invalid input');\n    }\n    if (typeof error.message === 'string') {\n      if (checkForHtml(error.message)) {\n        error.error = retrieveErrorMessage(error.message, error);\n      } else {\n        error.error = error.message;\n      }\n    }\n  }\n  if (error.stack) {\n    error = {\n      ...error,\n      error:\n        t('Unexpected error: ') +\n        (error.description || t('(no description, click to see stack trace)')),\n      stacktrace: error.stack,\n    };\n  } else if (error.responseText && error.responseText.indexOf('CSRF') >= 0) {\n    error = {\n      ...error,\n      error: t(COMMON_ERR_MESSAGES.SESSION_TIMED_OUT),\n    };\n  }\n\n  return { ...error, error: error.error }; // explicit ClientErrorObject\n}\n\nexport function getClientErrorObject(\n  response:\n    | SupersetClientResponse\n    | TimeoutError\n    | { response: Response }\n    | string,\n): Promise<ClientErrorObject> {\n  // takes a SupersetClientResponse as input, attempts to read response as Json\n  // if possible, and returns a Promise that resolves to a plain object with\n  // error key and text value.\n  return new Promise(resolve => {\n    if (typeof response === 'string') {\n      resolve({ error: parseStringResponse(response) });\n      return;\n    }\n\n    if (\n      response instanceof TypeError &&\n      response.message === 'Failed to fetch'\n    ) {\n      resolve({\n        error: t('Network error'),\n      });\n      return;\n    }\n\n    if (\n      'timeout' in response &&\n      'statusText' in response &&\n      response.statusText === 'timeout'\n    ) {\n      resolve({\n        ...response,\n        error: t('Request timed out'),\n        errors: [\n          {\n            error_type: ErrorTypeEnum.FRONTEND_TIMEOUT_ERROR,\n            extra: {\n              timeout: response.timeout / 1000,\n              issue_codes: [\n                {\n                  code: 1000,\n                  message: t('Issue 1000 - The dataset is too large to query.'),\n                },\n                {\n                  code: 1001,\n                  message: t(\n                    'Issue 1001 - The database is under an unusual load.',\n                  ),\n                },\n              ],\n            },\n            level: 'error',\n            message: 'Request timed out',\n          },\n        ],\n      });\n      return;\n    }\n\n    const responseObject =\n      response instanceof Response ? response : response.response;\n\n    if (responseObject && !responseObject.bodyUsed) {\n      // attempt to read the body as json, and fallback to text. we must clone\n      // the response in order to fallback to .text() because Response is\n      // single-read\n      responseObject\n        .clone()\n        .json()\n        .then(errorJson => {\n          // Destructuring instead of spreading to avoid loss of sibling properties to the body\n          const { url, status, statusText, redirected, type } = responseObject;\n          const responseSummary = { url, status, statusText, redirected, type };\n          const error = {\n            ...errorJson,\n            ...responseSummary,\n          };\n          resolve(parseErrorJson(error));\n        })\n        .catch(() => {\n          // fall back to reading as text\n          responseObject.text().then((errorText: any) => {\n            resolve({\n              // Destructuring not necessary here\n              ...responseObject,\n              error: retrieveErrorMessage(errorText, responseObject),\n            });\n          });\n        });\n      return;\n    }\n\n    // fall back to Response.statusText or generic error of we cannot read the response\n    let error = (response as any).statusText || (response as any).message;\n    if (!error) {\n      // eslint-disable-next-line no-console\n      console.error('non-standard error:', response);\n      error = t('An error occurred');\n    }\n    resolve({\n      ...responseObject,\n      error: parseStringResponse(error),\n    });\n  });\n}\n\n/*\n * Utility to get standardized error text for generic update failures\n */\nexport async function getErrorText(\n  errorObject: ErrorType,\n  source: ErrorTextSource,\n) {\n  const { error, message } = await getClientErrorObject(errorObject);\n  let errorText = t('Sorry, an unknown error occurred.');\n\n  if (error) {\n    errorText = t(\n      'Sorry, there was an error saving this %s: %s',\n      source,\n      error,\n    );\n  }\n  if (typeof message === 'string' && message === 'Forbidden') {\n    errorText = t('You do not have permission to edit this %s', source);\n  }\n  return errorText;\n}\n\nexport function getClientErrorMessage(\n  message: string,\n  clientError?: ClientErrorObject,\n) {\n  let finalMessage = message;\n  const errorMessage = clientError?.message || clientError?.error;\n  if (errorMessage) {\n    finalMessage = `${finalMessage}:\\n${errorMessage}`;\n  }\n  return finalMessage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}