{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";import _isEmpty from \"lodash/isEmpty\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect, useState } from 'react';\n\nimport moment from 'moment';\nimport { parseDttmToDate, css, customTimeRangeDecode, computeCustomDateTime } from '@superset-ui/core';\nimport { DatePicker } from 'antd';\nimport { useSelector } from 'react-redux';\nimport ControlHeader from 'src/explore/components/ControlHeader';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst MOMENT_FORMAT = 'YYYY-MM-DD';\nconst isTimeRangeEqual = (left, right) => _isEqual(left, right);\nconst isStartDateEqual = (left, right) => _isEqual(left, right);\nexport default function TimeOffsetControls({ onChange, ...props }) {\n  const [startDate, setStartDate] = useState('');\n  const [formatedDate, setFormatedDate] = useState(undefined);\n  const [customStartDateInFilter, setCustomStartDateInFilter] = useState(undefined);\n  const [formatedFilterDate, setFormatedFilterDate] = useState(undefined);\n  const [savedStartDate, setSavedStartDate] = useState(null);\n  const currentTimeRangeFilters = useSelector((state) => state.explore.form_data.adhoc_filters.filter((adhoc_filter) => adhoc_filter.operator === 'TEMPORAL_RANGE'), isTimeRangeEqual);\n  const currentStartDate = useSelector((state) => state.explore.form_data.start_date_offset, isStartDateEqual);\n  useEffect(() => {\n    if (savedStartDate !== currentStartDate) {\n      setSavedStartDate(currentStartDate);\n      onChange(moment(currentStartDate).format(MOMENT_FORMAT));\n    }\n  }, [currentStartDate]);\n  const previousCustomFilter = useSelector((state) => {var _state$explore$form_d;return (_state$explore$form_d = state.explore.form_data.adhoc_custom) == null ? void 0 : _state$explore$form_d.filter((adhoc_filter) => adhoc_filter.operator === 'TEMPORAL_RANGE');}, isTimeRangeEqual);\n  // let's use useCallback to compute the custom start date\n  const customTimeRange = useCallback((date) => {\n    const customRange = customTimeRangeDecode(date);\n    if (customRange.matchedFlag) {var _customStartDate;\n      const { sinceDatetime, sinceMode, sinceGrain, sinceGrainValue } = {\n        ...customRange.customRange\n      };\n      let customStartDate = null;\n      if (sinceMode !== 'relative') {\n        if (sinceMode === 'specific') {\n          customStartDate = new Date(sinceDatetime);\n        } else\n        {\n          customStartDate = parseDttmToDate(sinceDatetime, false, true);\n        }\n      } else\n      {\n        customStartDate = computeCustomDateTime(sinceDatetime, sinceGrain, sinceGrainValue);\n      }\n      (_customStartDate = customStartDate) == null ? void 0 : _customStartDate.setHours(0, 0, 0, 0);\n      setCustomStartDateInFilter(moment(customStartDate));\n    } else\n    {\n      setCustomStartDateInFilter(undefined);\n    }\n  }, [setCustomStartDateInFilter]);\n  useEffect(() => {\n    if (!_isEmpty(currentTimeRangeFilters)) {var _currentTimeRangeFilt, _currentTimeRangeFilt2, _currentTimeRangeFilt3;\n      customTimeRange((_currentTimeRangeFilt = (_currentTimeRangeFilt2 = currentTimeRangeFilters[0]) == null ? void 0 : _currentTimeRangeFilt2.comparator) != null ? _currentTimeRangeFilt : '');\n      const date = (_currentTimeRangeFilt3 = currentTimeRangeFilters[0]) == null ? void 0 : _currentTimeRangeFilt3.comparator.split(' : ')[0];\n      setFormatedFilterDate(moment(parseDttmToDate(date)));\n    } else\n    {\n      setCustomStartDateInFilter(undefined);\n      setFormatedFilterDate(moment(parseDttmToDate('')));\n    }\n  }, [currentTimeRangeFilters, customTimeRange]);\n  useEffect(() => {\n    if (!savedStartDate && (previousCustomFilter || customStartDateInFilter)) {var _previousCustomFilter;\n      let date = '';\n      if (_isEmpty(previousCustomFilter)) {var _currentTimeRangeFilt4;\n        date = (_currentTimeRangeFilt4 = currentTimeRangeFilters[0]) == null ? void 0 : _currentTimeRangeFilt4.comparator.split(' : ')[0];\n      } else\n      if (((_previousCustomFilter = previousCustomFilter[0]) == null ? void 0 : _previousCustomFilter.comparator.split(' : ')[0]) !== 'No filter') {var _previousCustomFilter2;\n        date = (_previousCustomFilter2 = previousCustomFilter[0]) == null ? void 0 : _previousCustomFilter2.comparator.split(' : ')[0];\n      }\n      if (customStartDateInFilter) {\n        setStartDate(customStartDateInFilter.toString());\n        setFormatedDate(moment(customStartDateInFilter));\n      } else\n      if (date) {\n        setStartDate(date);\n        setFormatedDate(moment(parseDttmToDate(date)));\n      }\n    } else\n    if (savedStartDate) {\n      setStartDate(savedStartDate);\n      setFormatedDate(moment(parseDttmToDate(savedStartDate)));\n    }\n  }, [previousCustomFilter, savedStartDate, customStartDateInFilter]);\n  useEffect(() => {\n    // When switching offsets from inherit and the previous custom is no longer valid\n    if (customStartDateInFilter) {\n      if (formatedDate && formatedDate > customStartDateInFilter) {\n        const resetDate = moment.\n        utc(customStartDateInFilter).\n        subtract(1, 'day');\n        setStartDate(resetDate.toString());\n        setFormatedDate(resetDate);\n        onChange(moment.utc(resetDate).format(MOMENT_FORMAT));\n      }\n    }\n    if (formatedDate &&\n    formatedFilterDate &&\n    formatedDate > formatedFilterDate) {\n      const resetDate = moment.utc(formatedFilterDate).subtract(1, 'day');\n      setStartDate(resetDate.toString());\n      setFormatedDate(resetDate);\n      onChange(moment.utc(resetDate).format(MOMENT_FORMAT));\n    }\n  }, [formatedFilterDate, formatedDate, customStartDateInFilter]);\n  const disabledDate = (current) => {\n    if (!customStartDateInFilter) {\n      return formatedFilterDate ?\n      current && current > formatedFilterDate :\n      false;\n    }\n    return current && current > moment(customStartDateInFilter);\n  };\n  return startDate || formatedDate ? _jsxs(\"div\", { children: [\n    _jsx(ControlHeader, { ...props }),\n    _jsx(DatePicker, { css: css`\n          width: 100%;\n        `, onChange: (datetime) => onChange(datetime ? datetime.format(MOMENT_FORMAT) : ''), defaultPickerValue: startDate ? moment(formatedDate).subtract(1, 'day') : undefined, disabledDate: disabledDate, defaultValue: moment(formatedDate), value: moment(formatedDate) })] }\n  ) : null;\n}__signature__(TimeOffsetControls, \"useState{[startDate, setStartDate]('')}\\nuseState{[formatedDate, setFormatedDate](undefined)}\\nuseState{[customStartDateInFilter, setCustomStartDateInFilter](undefined)}\\nuseState{[formatedFilterDate, setFormatedFilterDate](undefined)}\\nuseState{[savedStartDate, setSavedStartDate](null)}\\nuseSelector{currentTimeRangeFilters}\\nuseSelector{currentStartDate}\\nuseEffect{}\\nuseSelector{previousCustomFilter}\\nuseCallback{customTimeRange}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\", () => [useSelector, useSelector, useSelector]);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(MOMENT_FORMAT, \"MOMENT_FORMAT\", \"/app/superset-frontend/src/explore/components/controls/TimeOffsetControl.tsx\");reactHotLoader.register(isTimeRangeEqual, \"isTimeRangeEqual\", \"/app/superset-frontend/src/explore/components/controls/TimeOffsetControl.tsx\");reactHotLoader.register(isStartDateEqual, \"isStartDateEqual\", \"/app/superset-frontend/src/explore/components/controls/TimeOffsetControl.tsx\");reactHotLoader.register(TimeOffsetControls, \"TimeOffsetControls\", \"/app/superset-frontend/src/explore/components/controls/TimeOffsetControl.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["useCallback","useEffect","useState","moment","parseDttmToDate","css","customTimeRangeDecode","computeCustomDateTime","DatePicker","useSelector","ControlHeader","jsx","_jsx","jsxs","_jsxs","MOMENT_FORMAT","isTimeRangeEqual","left","right","_isEqual","isStartDateEqual","TimeOffsetControls","onChange","props","startDate","setStartDate","formatedDate","setFormatedDate","undefined","customStartDateInFilter","setCustomStartDateInFilter","formatedFilterDate","setFormatedFilterDate","savedStartDate","setSavedStartDate","currentTimeRangeFilters","state","explore","form_data","adhoc_filters","filter","adhoc_filter","operator","currentStartDate","start_date_offset","format","previousCustomFilter","_state$explore$form_d","adhoc_custom","customTimeRange","date","customRange","matchedFlag","_customStartDate","sinceDatetime","sinceMode","sinceGrain","sinceGrainValue","customStartDate","Date","setHours","_isEmpty","_currentTimeRangeFilt","_currentTimeRangeFilt2","_currentTimeRangeFilt3","comparator","split","_previousCustomFilter","_currentTimeRangeFilt4","_previousCustomFilter2","toString","resetDate","utc","subtract","disabledDate","current","children","datetime","defaultPickerValue","defaultValue","value","__signature__","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/app/superset-frontend/src/explore/components/controls/TimeOffsetControl.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ReactNode, useCallback, useEffect, useState } from 'react';\nimport { isEmpty, isEqual } from 'lodash';\nimport moment, { Moment } from 'moment';\nimport {\n  parseDttmToDate,\n  BinaryAdhocFilter,\n  SimpleAdhocFilter,\n  css,\n  customTimeRangeDecode,\n  computeCustomDateTime,\n} from '@superset-ui/core';\nimport { DatePicker } from 'antd';\nimport { RangePickerProps } from 'antd/lib/date-picker';\nimport { useSelector } from 'react-redux';\n\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport { RootState } from 'src/views/store';\n\nexport interface TimeOffsetControlsProps {\n  label?: ReactNode;\n  startDate?: string;\n  description?: string;\n  hovered?: boolean;\n  value?: Moment;\n  onChange: (datetime: string) => void;\n}\nconst MOMENT_FORMAT = 'YYYY-MM-DD';\n\nconst isTimeRangeEqual = (\n  left: BinaryAdhocFilter[],\n  right: BinaryAdhocFilter[],\n) => isEqual(left, right);\n\nconst isStartDateEqual = (left: string, right: string) => isEqual(left, right);\n\nexport default function TimeOffsetControls({\n  onChange,\n  ...props\n}: TimeOffsetControlsProps) {\n  const [startDate, setStartDate] = useState<string>('');\n  const [formatedDate, setFormatedDate] = useState<moment.Moment | undefined>(\n    undefined,\n  );\n  const [customStartDateInFilter, setCustomStartDateInFilter] = useState<\n    moment.Moment | undefined\n  >(undefined);\n  const [formatedFilterDate, setFormatedFilterDate] = useState<\n    moment.Moment | undefined\n  >(undefined);\n  const [savedStartDate, setSavedStartDate] = useState<string | null>(null);\n\n  const currentTimeRangeFilters = useSelector<RootState, BinaryAdhocFilter[]>(\n    state =>\n      state.explore.form_data.adhoc_filters.filter(\n        (adhoc_filter: SimpleAdhocFilter) =>\n          adhoc_filter.operator === 'TEMPORAL_RANGE',\n      ),\n    isTimeRangeEqual,\n  );\n\n  const currentStartDate = useSelector<RootState, string>(\n    state => state.explore.form_data.start_date_offset,\n    isStartDateEqual,\n  );\n\n  useEffect(() => {\n    if (savedStartDate !== currentStartDate) {\n      setSavedStartDate(currentStartDate);\n      onChange(moment(currentStartDate).format(MOMENT_FORMAT));\n    }\n  }, [currentStartDate]);\n\n  const previousCustomFilter = useSelector<RootState, BinaryAdhocFilter[]>(\n    state =>\n      state.explore.form_data.adhoc_custom?.filter(\n        (adhoc_filter: SimpleAdhocFilter) =>\n          adhoc_filter.operator === 'TEMPORAL_RANGE',\n      ),\n    isTimeRangeEqual,\n  );\n\n  // let's use useCallback to compute the custom start date\n  const customTimeRange = useCallback(\n    (date: string) => {\n      const customRange = customTimeRangeDecode(date);\n      if (customRange.matchedFlag) {\n        const { sinceDatetime, sinceMode, sinceGrain, sinceGrainValue } = {\n          ...customRange.customRange,\n        };\n        let customStartDate: Date | null = null;\n        if (sinceMode !== 'relative') {\n          if (sinceMode === 'specific') {\n            customStartDate = new Date(sinceDatetime);\n          } else {\n            customStartDate = parseDttmToDate(sinceDatetime, false, true);\n          }\n        } else {\n          customStartDate = computeCustomDateTime(\n            sinceDatetime,\n            sinceGrain,\n            sinceGrainValue,\n          );\n        }\n        customStartDate?.setHours(0, 0, 0, 0);\n        setCustomStartDateInFilter(moment(customStartDate));\n      } else {\n        setCustomStartDateInFilter(undefined);\n      }\n    },\n    [setCustomStartDateInFilter],\n  );\n\n  useEffect(() => {\n    if (!isEmpty(currentTimeRangeFilters)) {\n      customTimeRange(currentTimeRangeFilters[0]?.comparator ?? '');\n      const date = currentTimeRangeFilters[0]?.comparator.split(' : ')[0];\n      setFormatedFilterDate(moment(parseDttmToDate(date)));\n    } else {\n      setCustomStartDateInFilter(undefined);\n      setFormatedFilterDate(moment(parseDttmToDate('')));\n    }\n  }, [currentTimeRangeFilters, customTimeRange]);\n\n  useEffect(() => {\n    if (!savedStartDate && (previousCustomFilter || customStartDateInFilter)) {\n      let date = '';\n      if (isEmpty(previousCustomFilter)) {\n        date = currentTimeRangeFilters[0]?.comparator.split(' : ')[0];\n      } else if (\n        previousCustomFilter[0]?.comparator.split(' : ')[0] !== 'No filter'\n      ) {\n        date = previousCustomFilter[0]?.comparator.split(' : ')[0];\n      }\n      if (customStartDateInFilter) {\n        setStartDate(customStartDateInFilter.toString());\n        setFormatedDate(moment(customStartDateInFilter));\n      } else if (date) {\n        setStartDate(date);\n        setFormatedDate(moment(parseDttmToDate(date)));\n      }\n    } else if (savedStartDate) {\n      setStartDate(savedStartDate);\n      setFormatedDate(moment(parseDttmToDate(savedStartDate)));\n    }\n  }, [previousCustomFilter, savedStartDate, customStartDateInFilter]);\n\n  useEffect(() => {\n    // When switching offsets from inherit and the previous custom is no longer valid\n    if (customStartDateInFilter) {\n      if (formatedDate && formatedDate > customStartDateInFilter) {\n        const resetDate = moment\n          .utc(customStartDateInFilter)\n          .subtract(1, 'day');\n        setStartDate(resetDate.toString());\n        setFormatedDate(resetDate);\n        onChange(moment.utc(resetDate).format(MOMENT_FORMAT));\n      }\n    }\n    if (\n      formatedDate &&\n      formatedFilterDate &&\n      formatedDate > formatedFilterDate\n    ) {\n      const resetDate = moment.utc(formatedFilterDate).subtract(1, 'day');\n      setStartDate(resetDate.toString());\n      setFormatedDate(resetDate);\n      onChange(moment.utc(resetDate).format(MOMENT_FORMAT));\n    }\n  }, [formatedFilterDate, formatedDate, customStartDateInFilter]);\n\n  const disabledDate: RangePickerProps['disabledDate'] = current => {\n    if (!customStartDateInFilter) {\n      return formatedFilterDate\n        ? current && current > formatedFilterDate\n        : false;\n    }\n    return current && current > moment(customStartDateInFilter);\n  };\n\n  return startDate || formatedDate ? (\n    <div>\n      <ControlHeader {...props} />\n      <DatePicker\n        css={css`\n          width: 100%;\n        `}\n        onChange={(datetime: Moment) =>\n          onChange(datetime ? datetime.format(MOMENT_FORMAT) : '')\n        }\n        defaultPickerValue={\n          startDate ? moment(formatedDate).subtract(1, 'day') : undefined\n        }\n        disabledDate={disabledDate}\n        defaultValue={moment(formatedDate)}\n        value={moment(formatedDate)}\n      />\n    </div>\n  ) : null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}