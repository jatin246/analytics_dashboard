{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport { ComparisonType, CurrencyFormatter, ensureIsArray, extractTimegrain, GenericDataType, getMetricLabel, getNumberFormatter, getTimeFormatter, getTimeFormatterForGranularity, NumberFormats, QueryMode, t, SMART_DATE_ID, TimeFormats, getTimeOffset, parseDttmToDate } from '@superset-ui/core';\nimport { getColorFormatters } from '@superset-ui/chart-controls';\n\nimport isEqualColumns from './utils/isEqualColumns';\nimport DateWithFormatter from './utils/DateWithFormatter';\nimport { ColorSchemeEnum } from './types';\nconst { PERCENT_3_POINT } = NumberFormats;\nconst { DATABASE_DATETIME } = TimeFormats;\nfunction isNumeric(key, data = []) {\n  return data.every((x) => x[key] === null || x[key] === undefined || typeof x[key] === 'number');\n}\nconst processDataRecords = memoizeOne(function processDataRecords(data, columns) {\n  if (!(data != null && data[0])) {\n    return data || [];\n  }\n  const timeColumns = columns.filter((column) => column.dataType === GenericDataType.Temporal);\n  if (timeColumns.length > 0) {\n    return data.map((x) => {\n      const datum = { ...x };\n      timeColumns.forEach(({ key, formatter }) => {\n        // Convert datetime with a custom date class so we can use `String(...)`\n        // formatted value for global search, and `date.getTime()` for sorting.\n        datum[key] = new DateWithFormatter(x[key], {\n          formatter: formatter\n        });\n      });\n      return datum;\n    });\n  }\n  return data;\n});\nconst calculateDifferences = (originalValue, comparisonValue) => {\n  const valueDifference = originalValue - comparisonValue;\n  let percentDifferenceNum;\n  if (!originalValue && !comparisonValue) {\n    percentDifferenceNum = 0;\n  } else\n  if (!originalValue || !comparisonValue) {\n    percentDifferenceNum = originalValue ? 1 : -1;\n  } else\n  {\n    percentDifferenceNum =\n    (originalValue - comparisonValue) / Math.abs(comparisonValue);\n  }\n  return { valueDifference, percentDifferenceNum };\n};\nconst processComparisonTotals = (comparisonSuffix, totals) => {\n  if (!totals) {\n    return totals;\n  }\n  const transformedTotals = {};\n  totals.map((totalRecord) => Object.keys(totalRecord).forEach((key) => {\n    if (totalRecord[key] !== undefined && !key.includes(comparisonSuffix)) {var _transformedTotals, _totalRecord$key, _transformedTotals2, _totalRecord;\n      transformedTotals[`Main ${key}`] =\n      parseInt(((_transformedTotals = transformedTotals[`Main ${key}`]) == null ? void 0 : _transformedTotals.toString()) || '0', 10) +\n      parseInt(((_totalRecord$key = totalRecord[key]) == null ? void 0 : _totalRecord$key.toString()) || '0', 10);\n      transformedTotals[`# ${key}`] =\n      parseInt(((_transformedTotals2 = transformedTotals[`# ${key}`]) == null ? void 0 : _transformedTotals2.toString()) || '0', 10) +\n      parseInt(((_totalRecord = totalRecord[`${key}__${comparisonSuffix}`]) == null ? void 0 : _totalRecord.toString()) || '0', 10);\n      const { valueDifference, percentDifferenceNum } = calculateDifferences(transformedTotals[`Main ${key}`], transformedTotals[`# ${key}`]);\n      transformedTotals[`△ ${key}`] = valueDifference;\n      transformedTotals[`% ${key}`] = percentDifferenceNum;\n    }\n  }));\n  return transformedTotals;\n};\nconst processComparisonDataRecords = memoizeOne(function processComparisonDataRecords(originalData, originalColumns, comparisonSuffix) {\n  // Transform data\n  return originalData == null ? void 0 : originalData.map((originalItem) => {\n    const transformedItem = {};\n    originalColumns.forEach((origCol) => {\n      if ((origCol.isMetric || origCol.isPercentMetric) &&\n      !origCol.key.includes(comparisonSuffix) &&\n      origCol.isNumeric) {\n        const originalValue = originalItem[origCol.key] || 0;\n        const comparisonValue = origCol.isMetric ?\n        (originalItem == null ? void 0 : originalItem[`${origCol.key}__${comparisonSuffix}`]) || 0 :\n        originalItem[`%${origCol.key.slice(1)}__${comparisonSuffix}`] ||\n        0;\n        const { valueDifference, percentDifferenceNum } = calculateDifferences(originalValue, comparisonValue);\n        transformedItem[`Main ${origCol.key}`] = originalValue;\n        transformedItem[`# ${origCol.key}`] = comparisonValue;\n        transformedItem[`△ ${origCol.key}`] = valueDifference;\n        transformedItem[`% ${origCol.key}`] = percentDifferenceNum;\n      }\n    });\n    Object.keys(originalItem).forEach((key) => {\n      const isMetricOrPercentMetric = originalColumns.some((col) => col.key === key && (col.isMetric || col.isPercentMetric));\n      if (!isMetricOrPercentMetric) {\n        transformedItem[key] = originalItem[key];\n      }\n    });\n    return transformedItem;\n  });\n});\nconst processColumns = memoizeOne(function processColumns(props) {\n  const { datasource: { columnFormats, currencyFormats, verboseMap }, rawFormData: { table_timestamp_format: tableTimestampFormat, metrics: metrics_, percent_metrics: percentMetrics_, column_config: columnConfig = {} }, queriesData } = props;\n  const granularity = extractTimegrain(props.rawFormData);\n  const { data: records, colnames, coltypes } = queriesData[0] || {};\n  // convert `metrics` and `percentMetrics` to the key names in `data.records`\n  const metrics = (metrics_ != null ? metrics_ : []).map(getMetricLabel);\n  const rawPercentMetrics = (percentMetrics_ != null ? percentMetrics_ : []).map(getMetricLabel);\n  // column names for percent metrics always starts with a '%' sign.\n  const percentMetrics = rawPercentMetrics.map((x) => `%${x}`);\n  const metricsSet = new Set(metrics);\n  const percentMetricsSet = new Set(percentMetrics);\n  const rawPercentMetricsSet = new Set(rawPercentMetrics);\n  const columns = (colnames || []).\n  filter((key) =>\n  // if a metric was only added to percent_metrics, they should not show up in the table.\n  !(rawPercentMetricsSet.has(key) && !metricsSet.has(key))).\n  map((key, i) => {var _config$currencyForma;\n    const dataType = coltypes[i];\n    const config = columnConfig[key] || {};\n    // for the purpose of presentation, only numeric values are treated as metrics\n    // because users can also add things like `MAX(str_col)` as a metric.\n    const isMetric = metricsSet.has(key) && isNumeric(key, records);\n    const isPercentMetric = percentMetricsSet.has(key);\n    const label = isPercentMetric && verboseMap != null && verboseMap.hasOwnProperty(key.replace('%', '')) ?\n    `%${verboseMap[key.replace('%', '')]}` :\n    (verboseMap == null ? void 0 : verboseMap[key]) || key;\n    const isTime = dataType === GenericDataType.Temporal;\n    const isNumber = dataType === GenericDataType.Numeric;\n    const savedFormat = columnFormats == null ? void 0 : columnFormats[key];\n    const savedCurrency = currencyFormats == null ? void 0 : currencyFormats[key];\n    const numberFormat = config.d3NumberFormat || savedFormat;\n    const currency = (_config$currencyForma = config.currencyFormat) != null && _config$currencyForma.symbol ?\n    config.currencyFormat :\n    savedCurrency;\n    let formatter;\n    if (isTime || config.d3TimeFormat) {\n      // string types may also apply d3-time format\n      // pick adhoc format first, fallback to column level formats defined in\n      // datasource\n      const customFormat = config.d3TimeFormat || savedFormat;\n      const timeFormat = customFormat || tableTimestampFormat;\n      // When format is \"Adaptive Formatting\" (smart_date)\n      if (timeFormat === SMART_DATE_ID) {\n        if (granularity) {\n          // time column use formats based on granularity\n          formatter = getTimeFormatterForGranularity(granularity);\n        } else\n        if (customFormat) {\n          // other columns respect the column-specific format\n          formatter = getTimeFormatter(customFormat);\n        } else\n        if (isNumeric(key, records)) {\n          // if column is numeric values, it is considered a timestamp64\n          formatter = getTimeFormatter(DATABASE_DATETIME);\n        } else\n        {\n          // if no column-specific format, print cell as is\n          formatter = String;\n        }\n      } else\n      if (timeFormat) {\n        formatter = getTimeFormatter(timeFormat);\n      }\n    } else\n    if (isPercentMetric) {\n      // percent metrics have a default format\n      formatter = getNumberFormatter(numberFormat || PERCENT_3_POINT);\n    } else\n    if (isMetric || isNumber && (numberFormat || currency)) {\n      formatter = currency ?\n      new CurrencyFormatter({\n        d3Format: numberFormat,\n        currency\n      }) :\n      getNumberFormatter(numberFormat);\n    }\n    return {\n      key,\n      label,\n      dataType,\n      isNumeric: dataType === GenericDataType.Numeric,\n      isMetric,\n      isPercentMetric,\n      formatter,\n      config\n    };\n  });\n  return [metrics, percentMetrics, columns];\n}, isEqualColumns);\nconst processComparisonColumns = (columns, props, comparisonSuffix) => columns.\nmap((col) => {\n  const { datasource: { columnFormats }, rawFormData: { column_config: columnConfig = {} } } = props;\n  const config = columnConfig[col.key] || {};\n  const savedFormat = columnFormats == null ? void 0 : columnFormats[col.key];\n  const numberFormat = config.d3NumberFormat || savedFormat;\n  if ((col.isMetric || col.isPercentMetric) &&\n  !col.key.includes(comparisonSuffix) &&\n  col.isNumeric) {\n    return [\n    {\n      ...col,\n      label: t('Main'),\n      key: `${t('Main')} ${col.key}`\n    },\n    {\n      ...col,\n      label: `#`,\n      key: `# ${col.key}`\n    },\n    {\n      ...col,\n      label: `△`,\n      key: `△ ${col.key}`\n    },\n    {\n      ...col,\n      formatter: getNumberFormatter(numberFormat || PERCENT_3_POINT),\n      label: `%`,\n      key: `% ${col.key}`\n    }];\n\n  }\n  if (!col.isMetric &&\n  !col.isPercentMetric &&\n  !col.key.includes(comparisonSuffix)) {\n    return [col];\n  }\n  return [];\n}).\nflat();\n/**\n * Automatically set page size based on number of cells.\n */\nconst getPageSize = (pageSize, numRecords, numColumns) => {\n  if (typeof pageSize === 'number') {\n    // NaN is also has typeof === 'number'\n    return pageSize || 0;\n  }\n  if (typeof pageSize === 'string') {\n    return Number(pageSize) || 0;\n  }\n  // when pageSize not set, automatically add pagination if too many records\n  return numRecords * numColumns > 5000 ? 200 : 0;\n};\nconst defaultServerPaginationData = {};\nconst defaultColorFormatters = [];\nconst transformProps = (chartProps) => {var _chartProps$rawFormDa, _chartProps$rawFormDa2, _chartProps$rawFormDa3, _chartProps$rawFormDa4, _previousCustomTimeRa, _formData$extra_form_, _formData$extra_form_2, _TimeRangeFilters$, _parseDttmToDate, _baseQuery2, _baseQuery3, _totalQuery, _totalQuery2, _baseQuery4, _getColorFormatters, _baseQuery5, _chartProps$rawFormDa5;\n  const { height, width, rawFormData: formData, queriesData = [], filterState, ownState: serverPaginationData, hooks: { onAddFilter: onChangeFilter, setDataMask = () => {}, onContextMenu }, emitCrossFilters } = chartProps;\n  const { align_pn: alignPositiveNegative = true, color_pn: colorPositiveNegative = true, show_cell_bars: showCellBars = true, include_search: includeSearch = false, page_length: pageLength, server_pagination: serverPagination = false, server_page_length: serverPageLength = 10, order_desc: sortDesc = false, query_mode: queryMode, show_totals: showTotals, conditional_formatting: conditionalFormatting, allow_rearrange_columns: allowRearrangeColumns, allow_render_html: allowRenderHtml, time_compare, comparison_color_enabled: comparisonColorEnabled = false, comparison_color_scheme: comparisonColorScheme = ColorSchemeEnum.Green, comparison_type } = formData;\n  const isUsingTimeComparison = !_isEmpty(time_compare) &&\n  queryMode === QueryMode.Aggregate &&\n  comparison_type === ComparisonType.Values;\n  const calculateBasicStyle = (percentDifferenceNum, colorOption) => {\n    if (percentDifferenceNum === 0) {\n      return {\n        arrow: '',\n        arrowColor: '',\n        // eslint-disable-next-line theme-colors/no-literal-colors\n        backgroundColor: 'rgba(0,0,0,0.2)'\n      };\n    }\n    const isPositive = percentDifferenceNum > 0;\n    const arrow = isPositive ? '↑' : '↓';\n    const arrowColor = colorOption === ColorSchemeEnum.Green ?\n    isPositive ?\n    ColorSchemeEnum.Green :\n    ColorSchemeEnum.Red :\n    isPositive ?\n    ColorSchemeEnum.Red :\n    ColorSchemeEnum.Green;\n    const backgroundColor = colorOption === ColorSchemeEnum.Green ?\n    `rgba(${isPositive ? '0,150,0' : '150,0,0'},0.2)` :\n    `rgba(${isPositive ? '150,0,0' : '0,150,0'},0.2)`;\n    return { arrow, arrowColor, backgroundColor };\n  };\n  const getBasicColorFormatter = memoizeOne(function getBasicColorFormatter(originalData, originalColumns, selectedColumns) {\n    // Transform data\n    const relevantColumns = selectedColumns ?\n    originalColumns.filter((col) => selectedColumns.some((scol) => {var _scol$column;return scol == null ? void 0 : (_scol$column = scol.column) == null ? void 0 : _scol$column.includes(col.key);})) :\n    originalColumns;\n    return originalData == null ? void 0 : originalData.map((originalItem) => {\n      const item = {};\n      relevantColumns.forEach((origCol) => {\n        if ((origCol.isMetric || origCol.isPercentMetric) &&\n        !origCol.key.includes(ensureIsArray(timeOffsets)[0]) &&\n        origCol.isNumeric) {\n          const originalValue = originalItem[origCol.key] || 0;\n          const comparisonValue = origCol.isMetric ?\n          (originalItem == null ? void 0 : originalItem[`${origCol.key}__${ensureIsArray(timeOffsets)[0]}`]) || 0 :\n          originalItem[`%${origCol.key.slice(1)}__${ensureIsArray(timeOffsets)[0]}`] || 0;\n          const { percentDifferenceNum } = calculateDifferences(originalValue, comparisonValue);\n          if (selectedColumns) {\n            selectedColumns.forEach((col) => {var _col$column;\n              if (col != null && (_col$column = col.column) != null && _col$column.includes(origCol.key)) {\n                const { arrow, arrowColor, backgroundColor } = calculateBasicStyle(percentDifferenceNum, col.colorScheme || comparisonColorScheme);\n                item[col.column] = {\n                  mainArrow: arrow,\n                  arrowColor,\n                  backgroundColor\n                };\n              }\n            });\n          } else\n          {\n            const { arrow, arrowColor, backgroundColor } = calculateBasicStyle(percentDifferenceNum, comparisonColorScheme);\n            item[`${origCol.key}`] = {\n              mainArrow: arrow,\n              arrowColor,\n              backgroundColor\n            };\n          }\n        }\n      });\n      return item;\n    });\n  });\n  const getBasicColorFormatterForColumn = (originalData, originalColumns, conditionalFormatting) => {\n    const selectedColumns = conditionalFormatting == null ? void 0 : conditionalFormatting.filter((config) => config.column && (\n    config.colorScheme === ColorSchemeEnum.Green ||\n    config.colorScheme === ColorSchemeEnum.Red));\n    return selectedColumns != null && selectedColumns.length ?\n    getBasicColorFormatter(originalData, originalColumns, selectedColumns) :\n    undefined;\n  };\n  const timeGrain = extractTimegrain(formData);\n  const TimeRangeFilters = ((_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : (_chartProps$rawFormDa2 = _chartProps$rawFormDa.adhoc_filters) == null ? void 0 : _chartProps$rawFormDa2.filter((filter) => filter.operator === 'TEMPORAL_RANGE')) || [];\n  const previousCustomTimeRangeFilters = ((_chartProps$rawFormDa3 = chartProps.rawFormData) == null ? void 0 : (_chartProps$rawFormDa4 = _chartProps$rawFormDa3.adhoc_custom) == null ? void 0 : _chartProps$rawFormDa4.filter((filter) => filter.operator === 'TEMPORAL_RANGE')) || [];\n  let previousCustomStartDate = '';\n  if (!_isEmpty(previousCustomTimeRangeFilters) &&\n  ((_previousCustomTimeRa = previousCustomTimeRangeFilters[0]) == null ? void 0 : _previousCustomTimeRa.comparator) !== 'No Filter') {var _previousCustomTimeRa2;\n    previousCustomStartDate = (_previousCustomTimeRa2 =\n    previousCustomTimeRangeFilters[0]) == null ? void 0 : _previousCustomTimeRa2.comparator.split(' : ')[0];\n  }\n  const timeOffsets = getTimeOffset({\n    timeRangeFilter: {\n      ...TimeRangeFilters[0],\n      comparator: (_formData$extra_form_ = formData == null ? void 0 : (_formData$extra_form_2 = formData.extra_form_data) == null ? void 0 : _formData$extra_form_2.time_range) != null ? _formData$extra_form_ : (_TimeRangeFilters$ =\n      TimeRangeFilters[0]) == null ? void 0 : _TimeRangeFilters$.comparator\n    },\n    shifts: formData.time_compare,\n    startDate: previousCustomStartDate && !formData.start_date_offset ? (_parseDttmToDate =\n    parseDttmToDate(previousCustomStartDate)) == null ? void 0 : _parseDttmToDate.toUTCString() :\n    formData.start_date_offset\n  });\n  const comparisonSuffix = isUsingTimeComparison ?\n  ensureIsArray(timeOffsets)[0] :\n  '';\n  const [metrics, percentMetrics, columns] = processColumns(chartProps);\n  let comparisonColumns = [];\n  if (isUsingTimeComparison) {\n    comparisonColumns = processComparisonColumns(columns, chartProps, comparisonSuffix);\n  }\n  let baseQuery;\n  let countQuery;\n  let totalQuery;\n  let rowCount;\n  if (serverPagination) {var _countQuery$data$0$ro, _countQuery, _countQuery$data, _countQuery$data$;\n    [baseQuery, countQuery, totalQuery] = queriesData;\n    rowCount = (_countQuery$data$0$ro = (_countQuery = countQuery) == null ? void 0 : (_countQuery$data = _countQuery.data) == null ? void 0 : (_countQuery$data$ = _countQuery$data[0]) == null ? void 0 : _countQuery$data$.rowcount) != null ? _countQuery$data$0$ro : 0;\n  } else\n  {var _baseQuery$rowcount, _baseQuery;\n    [baseQuery, totalQuery] = queriesData;\n    rowCount = (_baseQuery$rowcount = (_baseQuery = baseQuery) == null ? void 0 : _baseQuery.rowcount) != null ? _baseQuery$rowcount : 0;\n  }\n  const data = processDataRecords((_baseQuery2 = baseQuery) == null ? void 0 : _baseQuery2.data, columns);\n  const comparisonData = processComparisonDataRecords((_baseQuery3 = baseQuery) == null ? void 0 : _baseQuery3.data, columns, comparisonSuffix);\n  const totals = showTotals && queryMode === QueryMode.Aggregate ?\n  isUsingTimeComparison ?\n  processComparisonTotals(comparisonSuffix, (_totalQuery = totalQuery) == null ? void 0 : _totalQuery.data) : (_totalQuery2 =\n  totalQuery) == null ? void 0 : _totalQuery2.data[0] :\n  undefined;\n  const passedData = isUsingTimeComparison ? comparisonData || [] : data;\n  const passedColumns = isUsingTimeComparison ? comparisonColumns : columns;\n  const basicColorFormatters = comparisonColorEnabled && getBasicColorFormatter((_baseQuery4 = baseQuery) == null ? void 0 : _baseQuery4.data, columns);\n  const columnColorFormatters = (_getColorFormatters = getColorFormatters(conditionalFormatting, passedData)) != null ? _getColorFormatters :\n  defaultColorFormatters;\n  const basicColorColumnFormatters = getBasicColorFormatterForColumn((_baseQuery5 = baseQuery) == null ? void 0 : _baseQuery5.data, columns, conditionalFormatting);\n  const startDateOffset = (_chartProps$rawFormDa5 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa5.start_date_offset;\n  return {\n    height,\n    width,\n    isRawRecords: queryMode === QueryMode.Raw,\n    data: passedData,\n    totals,\n    columns: passedColumns,\n    serverPagination,\n    metrics,\n    percentMetrics,\n    serverPaginationData: serverPagination ?\n    serverPaginationData :\n    defaultServerPaginationData,\n    setDataMask,\n    alignPositiveNegative,\n    colorPositiveNegative,\n    showCellBars,\n    sortDesc,\n    includeSearch,\n    rowCount,\n    pageSize: serverPagination ?\n    serverPageLength :\n    getPageSize(pageLength, data.length, columns.length),\n    filters: filterState.filters,\n    emitCrossFilters,\n    onChangeFilter,\n    columnColorFormatters,\n    timeGrain,\n    allowRearrangeColumns,\n    allowRenderHtml,\n    onContextMenu,\n    isUsingTimeComparison,\n    basicColorFormatters,\n    startDateOffset,\n    basicColorColumnFormatters\n  };\n};const _default =\ntransformProps;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(PERCENT_3_POINT, \"PERCENT_3_POINT\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(DATABASE_DATETIME, \"DATABASE_DATETIME\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(isNumeric, \"isNumeric\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(processDataRecords, \"processDataRecords\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(calculateDifferences, \"calculateDifferences\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(processComparisonTotals, \"processComparisonTotals\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(processComparisonDataRecords, \"processComparisonDataRecords\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(processColumns, \"processColumns\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(processComparisonColumns, \"processComparisonColumns\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(getPageSize, \"getPageSize\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(defaultServerPaginationData, \"defaultServerPaginationData\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(defaultColorFormatters, \"defaultColorFormatters\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["memoizeOne","ComparisonType","CurrencyFormatter","ensureIsArray","extractTimegrain","GenericDataType","getMetricLabel","getNumberFormatter","getTimeFormatter","getTimeFormatterForGranularity","NumberFormats","QueryMode","t","SMART_DATE_ID","TimeFormats","getTimeOffset","parseDttmToDate","getColorFormatters","isEqualColumns","DateWithFormatter","ColorSchemeEnum","PERCENT_3_POINT","DATABASE_DATETIME","isNumeric","key","data","every","x","undefined","processDataRecords","columns","timeColumns","filter","column","dataType","Temporal","length","map","datum","forEach","formatter","calculateDifferences","originalValue","comparisonValue","valueDifference","percentDifferenceNum","Math","abs","processComparisonTotals","comparisonSuffix","totals","transformedTotals","totalRecord","Object","keys","includes","_transformedTotals","_totalRecord$key","_transformedTotals2","_totalRecord","parseInt","toString","processComparisonDataRecords","originalData","originalColumns","originalItem","transformedItem","origCol","isMetric","isPercentMetric","slice","isMetricOrPercentMetric","some","col","processColumns","props","datasource","columnFormats","currencyFormats","verboseMap","rawFormData","table_timestamp_format","tableTimestampFormat","metrics","metrics_","percent_metrics","percentMetrics_","column_config","columnConfig","queriesData","granularity","records","colnames","coltypes","rawPercentMetrics","percentMetrics","metricsSet","Set","percentMetricsSet","rawPercentMetricsSet","has","i","_config$currencyForma","config","label","hasOwnProperty","replace","isTime","isNumber","Numeric","savedFormat","savedCurrency","numberFormat","d3NumberFormat","currency","currencyFormat","symbol","d3TimeFormat","customFormat","timeFormat","String","d3Format","processComparisonColumns","flat","getPageSize","pageSize","numRecords","numColumns","Number","defaultServerPaginationData","defaultColorFormatters","transformProps","chartProps","_chartProps$rawFormDa","_chartProps$rawFormDa2","_chartProps$rawFormDa3","_chartProps$rawFormDa4","_previousCustomTimeRa","_formData$extra_form_","_formData$extra_form_2","_TimeRangeFilters$","_parseDttmToDate","_baseQuery2","_baseQuery3","_totalQuery","_totalQuery2","_baseQuery4","_getColorFormatters","_baseQuery5","_chartProps$rawFormDa5","height","width","formData","filterState","ownState","serverPaginationData","hooks","onAddFilter","onChangeFilter","setDataMask","onContextMenu","emitCrossFilters","align_pn","alignPositiveNegative","color_pn","colorPositiveNegative","show_cell_bars","showCellBars","include_search","includeSearch","page_length","pageLength","server_pagination","serverPagination","server_page_length","serverPageLength","order_desc","sortDesc","query_mode","queryMode","show_totals","showTotals","conditional_formatting","conditionalFormatting","allow_rearrange_columns","allowRearrangeColumns","allow_render_html","allowRenderHtml","time_compare","comparison_color_enabled","comparisonColorEnabled","comparison_color_scheme","comparisonColorScheme","Green","comparison_type","isUsingTimeComparison","_isEmpty","Aggregate","Values","calculateBasicStyle","colorOption","arrow","arrowColor","backgroundColor","isPositive","Red","getBasicColorFormatter","selectedColumns","relevantColumns","scol","_scol$column","item","timeOffsets","_col$column","colorScheme","mainArrow","getBasicColorFormatterForColumn","timeGrain","TimeRangeFilters","adhoc_filters","operator","previousCustomTimeRangeFilters","adhoc_custom","previousCustomStartDate","comparator","_previousCustomTimeRa2","split","timeRangeFilter","extra_form_data","time_range","shifts","startDate","start_date_offset","toUTCString","comparisonColumns","baseQuery","countQuery","totalQuery","rowCount","_countQuery$data$0$ro","_countQuery","_countQuery$data","_countQuery$data$","rowcount","_baseQuery$rowcount","_baseQuery","comparisonData","passedData","passedColumns","basicColorFormatters","columnColorFormatters","basicColorColumnFormatters","startDateOffset","isRawRecords","Raw","filters","_default","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/app/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport {\n  ComparisonType,\n  CurrencyFormatter,\n  DataRecord,\n  ensureIsArray,\n  extractTimegrain,\n  GenericDataType,\n  getMetricLabel,\n  getNumberFormatter,\n  getTimeFormatter,\n  getTimeFormatterForGranularity,\n  NumberFormats,\n  QueryMode,\n  t,\n  SMART_DATE_ID,\n  TimeFormats,\n  TimeFormatter,\n  SimpleAdhocFilter,\n  getTimeOffset,\n  parseDttmToDate,\n} from '@superset-ui/core';\nimport {\n  ColorFormatters,\n  ConditionalFormattingConfig,\n  getColorFormatters,\n} from '@superset-ui/chart-controls';\n\nimport { isEmpty } from 'lodash';\nimport isEqualColumns from './utils/isEqualColumns';\nimport DateWithFormatter from './utils/DateWithFormatter';\nimport {\n  BasicColorFormatterType,\n  ColorSchemeEnum,\n  DataColumnMeta,\n  TableChartProps,\n  TableChartTransformedProps,\n} from './types';\n\nconst { PERCENT_3_POINT } = NumberFormats;\nconst { DATABASE_DATETIME } = TimeFormats;\n\nfunction isNumeric(key: string, data: DataRecord[] = []) {\n  return data.every(\n    x => x[key] === null || x[key] === undefined || typeof x[key] === 'number',\n  );\n}\n\nconst processDataRecords = memoizeOne(function processDataRecords(\n  data: DataRecord[] | undefined,\n  columns: DataColumnMeta[],\n) {\n  if (!data?.[0]) {\n    return data || [];\n  }\n  const timeColumns = columns.filter(\n    column => column.dataType === GenericDataType.Temporal,\n  );\n\n  if (timeColumns.length > 0) {\n    return data.map(x => {\n      const datum = { ...x };\n      timeColumns.forEach(({ key, formatter }) => {\n        // Convert datetime with a custom date class so we can use `String(...)`\n        // formatted value for global search, and `date.getTime()` for sorting.\n        datum[key] = new DateWithFormatter(x[key], {\n          formatter: formatter as TimeFormatter,\n        });\n      });\n      return datum;\n    });\n  }\n  return data;\n});\n\nconst calculateDifferences = (\n  originalValue: number,\n  comparisonValue: number,\n) => {\n  const valueDifference = originalValue - comparisonValue;\n  let percentDifferenceNum;\n  if (!originalValue && !comparisonValue) {\n    percentDifferenceNum = 0;\n  } else if (!originalValue || !comparisonValue) {\n    percentDifferenceNum = originalValue ? 1 : -1;\n  } else {\n    percentDifferenceNum =\n      (originalValue - comparisonValue) / Math.abs(comparisonValue);\n  }\n  return { valueDifference, percentDifferenceNum };\n};\n\nconst processComparisonTotals = (\n  comparisonSuffix: string,\n  totals?: DataRecord[],\n): DataRecord | undefined => {\n  if (!totals) {\n    return totals;\n  }\n  const transformedTotals: DataRecord = {};\n  totals.map((totalRecord: DataRecord) =>\n    Object.keys(totalRecord).forEach(key => {\n      if (totalRecord[key] !== undefined && !key.includes(comparisonSuffix)) {\n        transformedTotals[`Main ${key}`] =\n          parseInt(transformedTotals[`Main ${key}`]?.toString() || '0', 10) +\n          parseInt(totalRecord[key]?.toString() || '0', 10);\n        transformedTotals[`# ${key}`] =\n          parseInt(transformedTotals[`# ${key}`]?.toString() || '0', 10) +\n          parseInt(\n            totalRecord[`${key}__${comparisonSuffix}`]?.toString() || '0',\n            10,\n          );\n        const { valueDifference, percentDifferenceNum } = calculateDifferences(\n          transformedTotals[`Main ${key}`] as number,\n          transformedTotals[`# ${key}`] as number,\n        );\n        transformedTotals[`△ ${key}`] = valueDifference;\n        transformedTotals[`% ${key}`] = percentDifferenceNum;\n      }\n    }),\n  );\n\n  return transformedTotals;\n};\n\nconst processComparisonDataRecords = memoizeOne(\n  function processComparisonDataRecords(\n    originalData: DataRecord[] | undefined,\n    originalColumns: DataColumnMeta[],\n    comparisonSuffix: string,\n  ) {\n    // Transform data\n    return originalData?.map(originalItem => {\n      const transformedItem: DataRecord = {};\n      originalColumns.forEach(origCol => {\n        if (\n          (origCol.isMetric || origCol.isPercentMetric) &&\n          !origCol.key.includes(comparisonSuffix) &&\n          origCol.isNumeric\n        ) {\n          const originalValue = originalItem[origCol.key] || 0;\n          const comparisonValue = origCol.isMetric\n            ? originalItem?.[`${origCol.key}__${comparisonSuffix}`] || 0\n            : originalItem[`%${origCol.key.slice(1)}__${comparisonSuffix}`] ||\n              0;\n          const { valueDifference, percentDifferenceNum } =\n            calculateDifferences(\n              originalValue as number,\n              comparisonValue as number,\n            );\n\n          transformedItem[`Main ${origCol.key}`] = originalValue;\n          transformedItem[`# ${origCol.key}`] = comparisonValue;\n          transformedItem[`△ ${origCol.key}`] = valueDifference;\n          transformedItem[`% ${origCol.key}`] = percentDifferenceNum;\n        }\n      });\n\n      Object.keys(originalItem).forEach(key => {\n        const isMetricOrPercentMetric = originalColumns.some(\n          col => col.key === key && (col.isMetric || col.isPercentMetric),\n        );\n        if (!isMetricOrPercentMetric) {\n          transformedItem[key] = originalItem[key];\n        }\n      });\n\n      return transformedItem;\n    });\n  },\n);\n\nconst processColumns = memoizeOne(function processColumns(\n  props: TableChartProps,\n) {\n  const {\n    datasource: { columnFormats, currencyFormats, verboseMap },\n    rawFormData: {\n      table_timestamp_format: tableTimestampFormat,\n      metrics: metrics_,\n      percent_metrics: percentMetrics_,\n      column_config: columnConfig = {},\n    },\n    queriesData,\n  } = props;\n  const granularity = extractTimegrain(props.rawFormData);\n  const { data: records, colnames, coltypes } = queriesData[0] || {};\n  // convert `metrics` and `percentMetrics` to the key names in `data.records`\n  const metrics = (metrics_ ?? []).map(getMetricLabel);\n  const rawPercentMetrics = (percentMetrics_ ?? []).map(getMetricLabel);\n  // column names for percent metrics always starts with a '%' sign.\n  const percentMetrics = rawPercentMetrics.map((x: string) => `%${x}`);\n  const metricsSet = new Set(metrics);\n  const percentMetricsSet = new Set(percentMetrics);\n  const rawPercentMetricsSet = new Set(rawPercentMetrics);\n\n  const columns: DataColumnMeta[] = (colnames || [])\n    .filter(\n      key =>\n        // if a metric was only added to percent_metrics, they should not show up in the table.\n        !(rawPercentMetricsSet.has(key) && !metricsSet.has(key)),\n    )\n    .map((key: string, i) => {\n      const dataType = coltypes[i];\n      const config = columnConfig[key] || {};\n      // for the purpose of presentation, only numeric values are treated as metrics\n      // because users can also add things like `MAX(str_col)` as a metric.\n      const isMetric = metricsSet.has(key) && isNumeric(key, records);\n      const isPercentMetric = percentMetricsSet.has(key);\n      const label =\n        isPercentMetric && verboseMap?.hasOwnProperty(key.replace('%', ''))\n          ? `%${verboseMap[key.replace('%', '')]}`\n          : verboseMap?.[key] || key;\n      const isTime = dataType === GenericDataType.Temporal;\n      const isNumber = dataType === GenericDataType.Numeric;\n      const savedFormat = columnFormats?.[key];\n      const savedCurrency = currencyFormats?.[key];\n      const numberFormat = config.d3NumberFormat || savedFormat;\n      const currency = config.currencyFormat?.symbol\n        ? config.currencyFormat\n        : savedCurrency;\n\n      let formatter;\n\n      if (isTime || config.d3TimeFormat) {\n        // string types may also apply d3-time format\n        // pick adhoc format first, fallback to column level formats defined in\n        // datasource\n        const customFormat = config.d3TimeFormat || savedFormat;\n        const timeFormat = customFormat || tableTimestampFormat;\n        // When format is \"Adaptive Formatting\" (smart_date)\n        if (timeFormat === SMART_DATE_ID) {\n          if (granularity) {\n            // time column use formats based on granularity\n            formatter = getTimeFormatterForGranularity(granularity);\n          } else if (customFormat) {\n            // other columns respect the column-specific format\n            formatter = getTimeFormatter(customFormat);\n          } else if (isNumeric(key, records)) {\n            // if column is numeric values, it is considered a timestamp64\n            formatter = getTimeFormatter(DATABASE_DATETIME);\n          } else {\n            // if no column-specific format, print cell as is\n            formatter = String;\n          }\n        } else if (timeFormat) {\n          formatter = getTimeFormatter(timeFormat);\n        }\n      } else if (isPercentMetric) {\n        // percent metrics have a default format\n        formatter = getNumberFormatter(numberFormat || PERCENT_3_POINT);\n      } else if (isMetric || (isNumber && (numberFormat || currency))) {\n        formatter = currency\n          ? new CurrencyFormatter({\n              d3Format: numberFormat,\n              currency,\n            })\n          : getNumberFormatter(numberFormat);\n      }\n      return {\n        key,\n        label,\n        dataType,\n        isNumeric: dataType === GenericDataType.Numeric,\n        isMetric,\n        isPercentMetric,\n        formatter,\n        config,\n      };\n    });\n  return [metrics, percentMetrics, columns] as [\n    typeof metrics,\n    typeof percentMetrics,\n    typeof columns,\n  ];\n}, isEqualColumns);\n\nconst processComparisonColumns = (\n  columns: DataColumnMeta[],\n  props: TableChartProps,\n  comparisonSuffix: string,\n) =>\n  columns\n    .map(col => {\n      const {\n        datasource: { columnFormats },\n        rawFormData: { column_config: columnConfig = {} },\n      } = props;\n      const config = columnConfig[col.key] || {};\n      const savedFormat = columnFormats?.[col.key];\n      const numberFormat = config.d3NumberFormat || savedFormat;\n      if (\n        (col.isMetric || col.isPercentMetric) &&\n        !col.key.includes(comparisonSuffix) &&\n        col.isNumeric\n      ) {\n        return [\n          {\n            ...col,\n            label: t('Main'),\n            key: `${t('Main')} ${col.key}`,\n          },\n          {\n            ...col,\n            label: `#`,\n            key: `# ${col.key}`,\n          },\n          {\n            ...col,\n            label: `△`,\n            key: `△ ${col.key}`,\n          },\n          {\n            ...col,\n            formatter: getNumberFormatter(numberFormat || PERCENT_3_POINT),\n            label: `%`,\n            key: `% ${col.key}`,\n          },\n        ];\n      }\n      if (\n        !col.isMetric &&\n        !col.isPercentMetric &&\n        !col.key.includes(comparisonSuffix)\n      ) {\n        return [col];\n      }\n      return [];\n    })\n    .flat();\n\n/**\n * Automatically set page size based on number of cells.\n */\nconst getPageSize = (\n  pageSize: number | string | null | undefined,\n  numRecords: number,\n  numColumns: number,\n) => {\n  if (typeof pageSize === 'number') {\n    // NaN is also has typeof === 'number'\n    return pageSize || 0;\n  }\n  if (typeof pageSize === 'string') {\n    return Number(pageSize) || 0;\n  }\n  // when pageSize not set, automatically add pagination if too many records\n  return numRecords * numColumns > 5000 ? 200 : 0;\n};\n\nconst defaultServerPaginationData = {};\nconst defaultColorFormatters = [] as ColorFormatters;\nconst transformProps = (\n  chartProps: TableChartProps,\n): TableChartTransformedProps => {\n  const {\n    height,\n    width,\n    rawFormData: formData,\n    queriesData = [],\n    filterState,\n    ownState: serverPaginationData,\n    hooks: {\n      onAddFilter: onChangeFilter,\n      setDataMask = () => {},\n      onContextMenu,\n    },\n    emitCrossFilters,\n  } = chartProps;\n\n  const {\n    align_pn: alignPositiveNegative = true,\n    color_pn: colorPositiveNegative = true,\n    show_cell_bars: showCellBars = true,\n    include_search: includeSearch = false,\n    page_length: pageLength,\n    server_pagination: serverPagination = false,\n    server_page_length: serverPageLength = 10,\n    order_desc: sortDesc = false,\n    query_mode: queryMode,\n    show_totals: showTotals,\n    conditional_formatting: conditionalFormatting,\n    allow_rearrange_columns: allowRearrangeColumns,\n    allow_render_html: allowRenderHtml,\n    time_compare,\n    comparison_color_enabled: comparisonColorEnabled = false,\n    comparison_color_scheme: comparisonColorScheme = ColorSchemeEnum.Green,\n    comparison_type,\n  } = formData;\n  const isUsingTimeComparison =\n    !isEmpty(time_compare) &&\n    queryMode === QueryMode.Aggregate &&\n    comparison_type === ComparisonType.Values;\n\n  const calculateBasicStyle = (\n    percentDifferenceNum: number,\n    colorOption: ColorSchemeEnum,\n  ) => {\n    if (percentDifferenceNum === 0) {\n      return {\n        arrow: '',\n        arrowColor: '',\n        // eslint-disable-next-line theme-colors/no-literal-colors\n        backgroundColor: 'rgba(0,0,0,0.2)',\n      };\n    }\n    const isPositive = percentDifferenceNum > 0;\n    const arrow = isPositive ? '↑' : '↓';\n    const arrowColor =\n      colorOption === ColorSchemeEnum.Green\n        ? isPositive\n          ? ColorSchemeEnum.Green\n          : ColorSchemeEnum.Red\n        : isPositive\n          ? ColorSchemeEnum.Red\n          : ColorSchemeEnum.Green;\n    const backgroundColor =\n      colorOption === ColorSchemeEnum.Green\n        ? `rgba(${isPositive ? '0,150,0' : '150,0,0'},0.2)`\n        : `rgba(${isPositive ? '150,0,0' : '0,150,0'},0.2)`;\n\n    return { arrow, arrowColor, backgroundColor };\n  };\n\n  const getBasicColorFormatter = memoizeOne(function getBasicColorFormatter(\n    originalData: DataRecord[] | undefined,\n    originalColumns: DataColumnMeta[],\n    selectedColumns?: ConditionalFormattingConfig[],\n  ) {\n    // Transform data\n    const relevantColumns = selectedColumns\n      ? originalColumns.filter(col =>\n          selectedColumns.some(scol => scol?.column?.includes(col.key)),\n        )\n      : originalColumns;\n\n    return originalData?.map(originalItem => {\n      const item: { [key: string]: BasicColorFormatterType } = {};\n      relevantColumns.forEach(origCol => {\n        if (\n          (origCol.isMetric || origCol.isPercentMetric) &&\n          !origCol.key.includes(ensureIsArray(timeOffsets)[0]) &&\n          origCol.isNumeric\n        ) {\n          const originalValue = originalItem[origCol.key] || 0;\n          const comparisonValue = origCol.isMetric\n            ? originalItem?.[\n                `${origCol.key}__${ensureIsArray(timeOffsets)[0]}`\n              ] || 0\n            : originalItem[\n                `%${origCol.key.slice(1)}__${ensureIsArray(timeOffsets)[0]}`\n              ] || 0;\n          const { percentDifferenceNum } = calculateDifferences(\n            originalValue as number,\n            comparisonValue as number,\n          );\n\n          if (selectedColumns) {\n            selectedColumns.forEach(col => {\n              if (col?.column?.includes(origCol.key)) {\n                const { arrow, arrowColor, backgroundColor } =\n                  calculateBasicStyle(\n                    percentDifferenceNum,\n                    col.colorScheme || comparisonColorScheme,\n                  );\n                item[col.column] = {\n                  mainArrow: arrow,\n                  arrowColor,\n                  backgroundColor,\n                };\n              }\n            });\n          } else {\n            const { arrow, arrowColor, backgroundColor } = calculateBasicStyle(\n              percentDifferenceNum,\n              comparisonColorScheme,\n            );\n            item[`${origCol.key}`] = {\n              mainArrow: arrow,\n              arrowColor,\n              backgroundColor,\n            };\n          }\n        }\n      });\n      return item;\n    });\n  });\n\n  const getBasicColorFormatterForColumn = (\n    originalData: DataRecord[] | undefined,\n    originalColumns: DataColumnMeta[],\n    conditionalFormatting?: ConditionalFormattingConfig[],\n  ) => {\n    const selectedColumns = conditionalFormatting?.filter(\n      (config: ConditionalFormattingConfig) =>\n        config.column &&\n        (config.colorScheme === ColorSchemeEnum.Green ||\n          config.colorScheme === ColorSchemeEnum.Red),\n    );\n\n    return selectedColumns?.length\n      ? getBasicColorFormatter(originalData, originalColumns, selectedColumns)\n      : undefined;\n  };\n\n  const timeGrain = extractTimegrain(formData);\n  const TimeRangeFilters =\n    chartProps.rawFormData?.adhoc_filters?.filter(\n      (filter: SimpleAdhocFilter) => filter.operator === 'TEMPORAL_RANGE',\n    ) || [];\n  const previousCustomTimeRangeFilters: any =\n    chartProps.rawFormData?.adhoc_custom?.filter(\n      (filter: SimpleAdhocFilter) => filter.operator === 'TEMPORAL_RANGE',\n    ) || [];\n\n  let previousCustomStartDate = '';\n  if (\n    !isEmpty(previousCustomTimeRangeFilters) &&\n    previousCustomTimeRangeFilters[0]?.comparator !== 'No Filter'\n  ) {\n    previousCustomStartDate =\n      previousCustomTimeRangeFilters[0]?.comparator.split(' : ')[0];\n  }\n\n  const timeOffsets = getTimeOffset({\n    timeRangeFilter: {\n      ...TimeRangeFilters[0],\n      comparator:\n        formData?.extra_form_data?.time_range ??\n        (TimeRangeFilters[0] as any)?.comparator,\n    },\n    shifts: formData.time_compare,\n    startDate:\n      previousCustomStartDate && !formData.start_date_offset\n        ? parseDttmToDate(previousCustomStartDate)?.toUTCString()\n        : formData.start_date_offset,\n  });\n  const comparisonSuffix = isUsingTimeComparison\n    ? ensureIsArray(timeOffsets)[0]\n    : '';\n\n  const [metrics, percentMetrics, columns] = processColumns(chartProps);\n  let comparisonColumns: DataColumnMeta[] = [];\n  if (isUsingTimeComparison) {\n    comparisonColumns = processComparisonColumns(\n      columns,\n      chartProps,\n      comparisonSuffix,\n    );\n  }\n\n  let baseQuery;\n  let countQuery;\n  let totalQuery;\n  let rowCount;\n  if (serverPagination) {\n    [baseQuery, countQuery, totalQuery] = queriesData;\n    rowCount = (countQuery?.data?.[0]?.rowcount as number) ?? 0;\n  } else {\n    [baseQuery, totalQuery] = queriesData;\n    rowCount = baseQuery?.rowcount ?? 0;\n  }\n  const data = processDataRecords(baseQuery?.data, columns);\n  const comparisonData = processComparisonDataRecords(\n    baseQuery?.data,\n    columns,\n    comparisonSuffix,\n  );\n  const totals =\n    showTotals && queryMode === QueryMode.Aggregate\n      ? isUsingTimeComparison\n        ? processComparisonTotals(comparisonSuffix, totalQuery?.data)\n        : totalQuery?.data[0]\n      : undefined;\n\n  const passedData = isUsingTimeComparison ? comparisonData || [] : data;\n  const passedColumns = isUsingTimeComparison ? comparisonColumns : columns;\n\n  const basicColorFormatters =\n    comparisonColorEnabled && getBasicColorFormatter(baseQuery?.data, columns);\n  const columnColorFormatters =\n    getColorFormatters(conditionalFormatting, passedData) ??\n    defaultColorFormatters;\n\n  const basicColorColumnFormatters = getBasicColorFormatterForColumn(\n    baseQuery?.data,\n    columns,\n    conditionalFormatting,\n  );\n\n  const startDateOffset = chartProps.rawFormData?.start_date_offset;\n  return {\n    height,\n    width,\n    isRawRecords: queryMode === QueryMode.Raw,\n    data: passedData,\n    totals,\n    columns: passedColumns,\n    serverPagination,\n    metrics,\n    percentMetrics,\n    serverPaginationData: serverPagination\n      ? serverPaginationData\n      : defaultServerPaginationData,\n    setDataMask,\n    alignPositiveNegative,\n    colorPositiveNegative,\n    showCellBars,\n    sortDesc,\n    includeSearch,\n    rowCount,\n    pageSize: serverPagination\n      ? serverPageLength\n      : getPageSize(pageLength, data.length, columns.length),\n    filters: filterState.filters,\n    emitCrossFilters,\n    onChangeFilter,\n    columnColorFormatters,\n    timeGrain,\n    allowRearrangeColumns,\n    allowRenderHtml,\n    onContextMenu,\n    isUsingTimeComparison,\n    basicColorFormatters,\n    startDateOffset,\n    basicColorColumnFormatters,\n  };\n};\n\nexport default transformProps;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}