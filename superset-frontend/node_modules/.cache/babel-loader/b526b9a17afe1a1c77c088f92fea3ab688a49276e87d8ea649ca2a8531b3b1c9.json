{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { scaleOrdinal } from 'd3-scale';\nimport { ExtensibleFunction } from '../models';\nimport stringifyAndTrim from './stringifyAndTrim';\nimport getLabelsColorMap from './LabelsColorMapSingleton';\nimport { getAnalogousColors } from './utils';\nimport { FeatureFlag, isFeatureEnabled } from '../utils';\nclass CategoricalColorScale extends ExtensibleFunction {\n\n\n\n\n\n\n\n  /**\n   * Constructor\n   * @param {*} colors an array of colors\n   * @param {*} forcedColors optional parameter that comes from parent\n   * (usually CategoricalColorNamespace)\n   */\n  constructor(colors, forcedColors = {}) {\n    super((value, sliceId, colorScheme) => this.getColor(value, sliceId, colorScheme));\n    // holds original color scheme colors\n    this.originColors = void 0;this.colors = void 0;this.scale = void 0;this.forcedColors = void 0;this.labelsColorMapInstance = void 0;this.chartLabelsColorMap = void 0;this.multiple = void 0;this.originColors = colors;\n    // holds the extended color range (includes analagous colors)\n    this.colors = colors;\n    // holds the values of this specific slice (label+color)\n    this.chartLabelsColorMap = new Map();\n    // shared color map instance (when context is shared, i.e. dashboard)\n    this.labelsColorMapInstance = getLabelsColorMap();\n    // holds the multiple value for analogous colors range\n    this.multiple = 0;\n    this.scale = scaleOrdinal();\n    this.scale.range(colors);\n    // reserve fixed colors in parent map based on their index in the scale\n    Object.entries(forcedColors).forEach(([key, value]) => {\n      if (typeof value === 'number') {\n        // eslint-disable-next-line no-param-reassign\n        forcedColors[key] = colors[value % colors.length];\n      }\n    });\n    // forced colors from parent (usually CategoricalColorNamespace)\n    // currently used in dashboards to set custom label colors\n    this.forcedColors = forcedColors;\n  }\n  /**\n   * Increment the color range with analogous colors\n   */\n  incrementColorRange() {\n    const multiple = Math.floor(this.domain().length / this.originColors.length);\n    // the domain has grown larger than the original range\n    // increments the range with analogous colors\n    if (multiple > this.multiple) {\n      this.multiple = multiple;\n      const newRange = getAnalogousColors(this.originColors, multiple);\n      const extendedColors = this.originColors.concat(newRange);\n      this.range(extendedColors);\n      this.colors = extendedColors;\n    }\n  }\n  /**\n   * Get the color for a given value\n   *\n   * @param value the value of a label to get the color for\n   * @param sliceId the ID of the current chart\n   * @param colorScheme the original color scheme of the chart\n   * @returns the color or the next available color\n   */\n  getColor(value, sliceId, colorScheme) {var _this$forcedColors;\n    const cleanedValue = stringifyAndTrim(value);\n    // priority: forced color (i.e. custom label colors) > shared color > scale color\n    const forcedColor = (_this$forcedColors = this.forcedColors) == null ? void 0 : _this$forcedColors[cleanedValue];\n    const isExistingLabel = this.chartLabelsColorMap.has(cleanedValue);\n    let color = forcedColor || this.scale(cleanedValue);\n    // a forced color will always be used independently of the usage count\n    if (!forcedColor && !isExistingLabel) {\n      if (isFeatureEnabled(FeatureFlag.UseAnalagousColors)) {\n        this.incrementColorRange();\n      }\n      if (\n      // feature flag to be deprecated (will become standard behaviour)\n      isFeatureEnabled(FeatureFlag.AvoidColorsCollision) &&\n      this.isColorUsed(color)) {\n        // fallback to least used color\n        color = this.getNextAvailableColor(color);\n      }\n    }\n    // keep track of values in this slice\n    this.chartLabelsColorMap.set(cleanedValue, color);\n    // store the value+color in the LabelsColorMapSingleton\n    if (sliceId) {\n      this.labelsColorMapInstance.addSlice(cleanedValue, color, sliceId, colorScheme);\n    }\n    return color;\n  }\n  /**\n   * Verify if a color is used in this slice\n   *\n   * @param color\n   * @returns true if the color is used in this slice\n   */\n  isColorUsed(color) {\n    return this.getColorUsageCount(color) > 0;\n  }\n  /**\n   * Get the count of the color usage in this slice\n   *\n   * @param sliceId the ID of the current slice\n   * @param color the color to check\n   * @returns the count of the color usage in this slice\n   */\n  getColorUsageCount(currentColor) {\n    let count = 0;\n    this.chartLabelsColorMap.forEach((color) => {\n      if (color === currentColor) {\n        count += 1;\n      }\n    });\n    return count;\n  }\n  /**\n   * Lower chances of color collision by returning the least used color\n   * Checks across colors of current slice within LabelsColorMapSingleton\n   *\n   * @param currentColor the current color\n   * @returns the least used color that is not the excluded color\n   */\n  getNextAvailableColor(currentColor) {\n    const colorUsageArray = this.colors.map((color) => ({\n      color,\n      count: this.getColorUsageCount(color)\n    }));\n    const currentColorCount = this.getColorUsageCount(currentColor);\n    const otherColors = colorUsageArray.filter((colorEntry) => colorEntry.color !== currentColor);\n    // all other colors are used as much or more than currentColor\n    const hasNoneAvailable = otherColors.every((colorEntry) => colorEntry.count >= currentColorCount);\n    // fallback to currentColor color\n    if (!otherColors.length || hasNoneAvailable) {\n      return currentColor;\n    }\n    // Finding the least used color\n    const leastUsedColor = otherColors.reduce((min, entry) => entry.count < min.count ? entry : min).color;\n    return leastUsedColor;\n  }\n  /**\n   * Enforce specific color for a given value at the scale level\n   * Overrides any existing color and forced color for the given value\n   *\n   * @param {*} value value\n   * @param {*} forcedColor forcedColor\n   * @returns {CategoricalColorScale}\n   */\n  setColor(value, forcedColor) {\n    this.forcedColors[stringifyAndTrim(value)] = forcedColor;\n    return this;\n  }\n  /**\n   * Get a mapping of data values to colors\n   *\n   * @returns an object where the key is the data value and the value is the hex color code\n   */\n  getColorMap() {\n    const colorMap = {};\n    this.scale.domain().forEach((value) => {\n      colorMap[value.toString()] = this.scale(value);\n    });\n    return {\n      ...colorMap,\n      ...this.forcedColors\n    };\n  }\n  /**\n   * Return an exact copy of this scale.\n   * Changes to this scale will not affect the returned scale and vice versa.\n   *\n   * @returns {CategoricalColorScale} A copy of this scale.\n   */\n  copy() {\n    const copy = new CategoricalColorScale(this.scale.range(), this.forcedColors);\n    copy.forcedColors = { ...this.forcedColors };\n    copy.domain(this.domain());\n    copy.unknown(this.unknown());\n    return copy;\n  }\n  domain(newDomain) {\n    if (typeof newDomain === 'undefined') {\n      return this.scale.domain();\n    }\n    this.scale.domain(newDomain);\n    return this;\n  }\n  range(newRange) {\n    if (typeof newRange === 'undefined') {\n      return this.scale.range();\n    }\n    this.colors = newRange;\n    this.scale.range(newRange);\n    return this;\n  }\n  unknown(value) {\n    if (typeof value === 'undefined') {\n      return this.scale.unknown();\n    }\n    this.scale.unknown(value);\n    return this;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}const _default = CategoricalColorScale;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(CategoricalColorScale, \"CategoricalColorScale\", \"/app/superset-frontend/packages/superset-ui-core/src/color/CategoricalColorScale.ts\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/packages/superset-ui-core/src/color/CategoricalColorScale.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["scaleOrdinal","ExtensibleFunction","stringifyAndTrim","getLabelsColorMap","getAnalogousColors","FeatureFlag","isFeatureEnabled","CategoricalColorScale","constructor","colors","forcedColors","value","sliceId","colorScheme","getColor","originColors","scale","labelsColorMapInstance","chartLabelsColorMap","multiple","Map","range","Object","entries","forEach","key","length","incrementColorRange","Math","floor","domain","newRange","extendedColors","concat","_this$forcedColors","cleanedValue","forcedColor","isExistingLabel","has","color","UseAnalagousColors","AvoidColorsCollision","isColorUsed","getNextAvailableColor","set","addSlice","getColorUsageCount","currentColor","count","colorUsageArray","map","currentColorCount","otherColors","filter","colorEntry","hasNoneAvailable","every","leastUsedColor","reduce","min","entry","setColor","getColorMap","colorMap","toString","copy","unknown","newDomain","__reactstandin__regenerateByEval","code","eval","_default","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/app/superset-frontend/packages/superset-ui-core/src/color/CategoricalColorScale.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { scaleOrdinal, ScaleOrdinal } from 'd3-scale';\nimport { ExtensibleFunction } from '../models';\nimport { ColorsInitLookup, ColorsLookup } from './types';\nimport stringifyAndTrim from './stringifyAndTrim';\nimport getLabelsColorMap from './LabelsColorMapSingleton';\nimport { getAnalogousColors } from './utils';\nimport { FeatureFlag, isFeatureEnabled } from '../utils';\n\n// Use type augmentation to correct the fact that\n// an instance of CategoricalScale is also a function\ninterface CategoricalColorScale {\n  (x: { toString(): string }, y?: number, w?: string): string;\n}\n\nclass CategoricalColorScale extends ExtensibleFunction {\n  originColors: string[];\n\n  colors: string[];\n\n  scale: ScaleOrdinal<{ toString(): string }, string>;\n\n  forcedColors: ColorsLookup;\n\n  labelsColorMapInstance: ReturnType<typeof getLabelsColorMap>;\n\n  chartLabelsColorMap: Map<string, string>;\n\n  multiple: number;\n\n  /**\n   * Constructor\n   * @param {*} colors an array of colors\n   * @param {*} forcedColors optional parameter that comes from parent\n   * (usually CategoricalColorNamespace)\n   */\n  constructor(colors: string[], forcedColors: ColorsInitLookup = {}) {\n    super((value: string, sliceId?: number, colorScheme?: string) =>\n      this.getColor(value, sliceId, colorScheme),\n    );\n    // holds original color scheme colors\n    this.originColors = colors;\n    // holds the extended color range (includes analagous colors)\n    this.colors = colors;\n    // holds the values of this specific slice (label+color)\n    this.chartLabelsColorMap = new Map();\n    // shared color map instance (when context is shared, i.e. dashboard)\n    this.labelsColorMapInstance = getLabelsColorMap();\n    // holds the multiple value for analogous colors range\n    this.multiple = 0;\n\n    this.scale = scaleOrdinal<{ toString(): string }, string>();\n    this.scale.range(colors);\n\n    // reserve fixed colors in parent map based on their index in the scale\n    Object.entries(forcedColors).forEach(([key, value]) => {\n      if (typeof value === 'number') {\n        // eslint-disable-next-line no-param-reassign\n        forcedColors[key] = colors[value % colors.length];\n      }\n    });\n\n    // forced colors from parent (usually CategoricalColorNamespace)\n    // currently used in dashboards to set custom label colors\n    this.forcedColors = forcedColors as ColorsLookup;\n  }\n\n  /**\n   * Increment the color range with analogous colors\n   */\n  incrementColorRange() {\n    const multiple = Math.floor(\n      this.domain().length / this.originColors.length,\n    );\n    // the domain has grown larger than the original range\n    // increments the range with analogous colors\n    if (multiple > this.multiple) {\n      this.multiple = multiple;\n      const newRange = getAnalogousColors(this.originColors, multiple);\n      const extendedColors = this.originColors.concat(newRange);\n\n      this.range(extendedColors);\n      this.colors = extendedColors;\n    }\n  }\n\n  /**\n   * Get the color for a given value\n   *\n   * @param value the value of a label to get the color for\n   * @param sliceId the ID of the current chart\n   * @param colorScheme the original color scheme of the chart\n   * @returns the color or the next available color\n   */\n  getColor(value?: string, sliceId?: number, colorScheme?: string): string {\n    const cleanedValue = stringifyAndTrim(value);\n    // priority: forced color (i.e. custom label colors) > shared color > scale color\n    const forcedColor = this.forcedColors?.[cleanedValue];\n    const isExistingLabel = this.chartLabelsColorMap.has(cleanedValue);\n    let color = forcedColor || this.scale(cleanedValue);\n\n    // a forced color will always be used independently of the usage count\n    if (!forcedColor && !isExistingLabel) {\n      if (isFeatureEnabled(FeatureFlag.UseAnalagousColors)) {\n        this.incrementColorRange();\n      }\n      if (\n        // feature flag to be deprecated (will become standard behaviour)\n        isFeatureEnabled(FeatureFlag.AvoidColorsCollision) &&\n        this.isColorUsed(color)\n      ) {\n        // fallback to least used color\n        color = this.getNextAvailableColor(color);\n      }\n    }\n\n    // keep track of values in this slice\n    this.chartLabelsColorMap.set(cleanedValue, color);\n\n    // store the value+color in the LabelsColorMapSingleton\n    if (sliceId) {\n      this.labelsColorMapInstance.addSlice(\n        cleanedValue,\n        color,\n        sliceId,\n        colorScheme,\n      );\n    }\n    return color;\n  }\n\n  /**\n   * Verify if a color is used in this slice\n   *\n   * @param color\n   * @returns true if the color is used in this slice\n   */\n  isColorUsed(color: string): boolean {\n    return this.getColorUsageCount(color) > 0;\n  }\n\n  /**\n   * Get the count of the color usage in this slice\n   *\n   * @param sliceId the ID of the current slice\n   * @param color the color to check\n   * @returns the count of the color usage in this slice\n   */\n  getColorUsageCount(currentColor: string): number {\n    let count = 0;\n    this.chartLabelsColorMap.forEach(color => {\n      if (color === currentColor) {\n        count += 1;\n      }\n    });\n    return count;\n  }\n\n  /**\n   * Lower chances of color collision by returning the least used color\n   * Checks across colors of current slice within LabelsColorMapSingleton\n   *\n   * @param currentColor the current color\n   * @returns the least used color that is not the excluded color\n   */\n  getNextAvailableColor(currentColor: string) {\n    const colorUsageArray = this.colors.map(color => ({\n      color,\n      count: this.getColorUsageCount(color),\n    }));\n    const currentColorCount = this.getColorUsageCount(currentColor);\n    const otherColors = colorUsageArray.filter(\n      colorEntry => colorEntry.color !== currentColor,\n    );\n    // all other colors are used as much or more than currentColor\n    const hasNoneAvailable = otherColors.every(\n      colorEntry => colorEntry.count >= currentColorCount,\n    );\n\n    // fallback to currentColor color\n    if (!otherColors.length || hasNoneAvailable) {\n      return currentColor;\n    }\n\n    // Finding the least used color\n    const leastUsedColor = otherColors.reduce((min, entry) =>\n      entry.count < min.count ? entry : min,\n    ).color;\n\n    return leastUsedColor;\n  }\n\n  /**\n   * Enforce specific color for a given value at the scale level\n   * Overrides any existing color and forced color for the given value\n   *\n   * @param {*} value value\n   * @param {*} forcedColor forcedColor\n   * @returns {CategoricalColorScale}\n   */\n  setColor(value: string, forcedColor: string) {\n    this.forcedColors[stringifyAndTrim(value)] = forcedColor;\n    return this;\n  }\n\n  /**\n   * Get a mapping of data values to colors\n   *\n   * @returns an object where the key is the data value and the value is the hex color code\n   */\n  getColorMap() {\n    const colorMap: { [key: string]: string | undefined } = {};\n    this.scale.domain().forEach(value => {\n      colorMap[value.toString()] = this.scale(value);\n    });\n\n    return {\n      ...colorMap,\n      ...this.forcedColors,\n    };\n  }\n\n  /**\n   * Return an exact copy of this scale.\n   * Changes to this scale will not affect the returned scale and vice versa.\n   *\n   * @returns {CategoricalColorScale} A copy of this scale.\n   */\n  copy() {\n    const copy = new CategoricalColorScale(\n      this.scale.range(),\n      this.forcedColors,\n    );\n    copy.forcedColors = { ...this.forcedColors };\n    copy.domain(this.domain());\n    copy.unknown(this.unknown());\n    return copy;\n  }\n\n  /**\n   * Returns the scale's current domain.\n   */\n  domain(): { toString(): string }[];\n\n  /**\n   * Expands the domain to include the specified array of values.\n   */\n  domain(newDomain: { toString(): string }[]): this;\n\n  domain(newDomain?: { toString(): string }[]): unknown {\n    if (typeof newDomain === 'undefined') {\n      return this.scale.domain();\n    }\n\n    this.scale.domain(newDomain);\n    return this;\n  }\n\n  /**\n   * Returns the scale's current range.\n   */\n  range(): string[];\n\n  /**\n   * Sets the range of the ordinal scale to the specified array of values.\n   *\n   * The first element in the domain will be mapped to the first element in range, the second domain value to the second range value, and so on.\n   *\n   * If there are fewer elements in the range than in the domain, the scale will reuse values from the start of the range.\n   *\n   * @param newRange Array of range values.\n   */\n  range(newRange: string[]): this;\n\n  range(newRange?: string[]): unknown {\n    if (typeof newRange === 'undefined') {\n      return this.scale.range();\n    }\n\n    this.colors = newRange;\n    this.scale.range(newRange);\n    return this;\n  }\n\n  /**\n   * Returns the current unknown value, which defaults to \"implicit\".\n   */\n  unknown(): string | { name: 'implicit' };\n\n  /**\n   * Sets the output value of the scale for unknown input values and returns this scale.\n   * The implicit value enables implicit domain construction. scaleImplicit can be used as a convenience to set the implicit value.\n   *\n   * @param value Unknown value to be used or scaleImplicit to set implicit scale generation.\n   */\n  unknown(value: string | { name: 'implicit' }): this;\n\n  unknown(value?: string | { name: 'implicit' }): unknown {\n    if (typeof value === 'undefined') {\n      return this.scale.unknown();\n    }\n\n    this.scale.unknown(value);\n    return this;\n  }\n}\n\nexport default CategoricalColorScale;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}